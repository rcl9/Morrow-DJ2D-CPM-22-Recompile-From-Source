.comment \

Z80 CBIOS Version 2 for Exidy Sorcerer + Morrow DJ2D

This is the last in the Version 2 series of Sorcerer Z80 Bios's. 
It is a complete BIOS in the sense that it still suppports all disk formats. 
The only stripped out parts are the IOBYTE redirection capabilities 
that can still be found in Z80BIOS.MAC. This current version supports 
RCL9's S-100 clock module upon warm start and the new EXMON3 
monitor rom.

*****************************************************************
*								*
* Cbios for CP/M Ver 2.2 for Disk Jockey 2D controller (all	*
* revs). Handles diskettes with sector sizes of 128 bytes	*
* single density, 256, 512, 1024 bytes double density.		*
*								*
* Written by Bobby Dale Gifford.				*
* 9/1/79							*
*								*
* Disk Map of sectors used by Cold Boot, Warm Boot, Firmware,	*
* and CP/M:							*
*								*
* trk 0 sec  1 = First sector of cold boot.		e700h	*
*     0      2 = Cold boot 256.				  80h	*
*     0      3 = Cold boot 512.				  80h	*
*     0      4 = Cold boot 1024.			  80h	*
*     0      5 = Warm boot 256.				  80h	*
*     0      6 = Warm boot 512.				  80h	*
*     0      7 = Warm boot 1024.			  80h	*
*     0      8 = Cold/Warm boot.			3200h	*
*     0      9 = Firmware.				e400h	*
*     0     10 = Firmware+80h.				e480h	*
*     0     11 = Firmware+100h				e500h	*
*     0     12 = Firmware+180h.				e580h	*
*     0     13 = Firmware+200h.				e600h	*
*     0     14 = Firmware+280h.				e680h	*
*     0     15 = Firmware+300h.				e700h	*
*     0     16 = Firmware+380h.				e780h	*
*     0     17 = CCP.					2d00
*     0     10 = CCP+80h.				2d80h	*
*     0     12 = CCP+100h.				2e00h	*
*     0     14 = CCP+180h.				2e80h	*
*     0     16 = CCP+200h.				2f00h	*
*     0     18 = CCP+280h.				2f80h	*
*     0     20 = CCP+300h.				3000h	*
*     0     22 = CCP+380h.				3080h	*
*     0     24 = CCP+400h.				3100h	*
*     0     26 = CCP+480h.				3180h	*
*     1        = Rest of CP/M.			  3200h-4fffh	*
*								*
*****************************************************************
\
	title	'*** Cbios For CP/M Ver. 2.2 ***'

.comment \
*****************************************************************
*								*
* The following revision number is in reference to the CP/M	*
* 2.0 Cbios. 							*
*								*
*****************************************************************
\
revnum	equ	33		;Cbios revision number
cpmrev	equ	22		;CP/M revision number

.comment \
*****************************************************************
*								*
* The following equates relate the Thinker Toys 2D controller.	*
* If the controller is non standard (0E000H) only the ORIGIN	*
* equate need be changed. This version of the Cbios will work	*
* with 2D controller boards rev 0, 1, 3, 3.1, 4.		*
*								*
*****************************************************************
\
origin	equ	0D000H
djram	equ	origin+400h	;Disk Jockey 2D RAM address
djcin	equ	djram+3h	;Disk Jockey 2D character input routine
djcout	equ	djram+6h	;Disk Jockey 2D character output routine
djhome	equ	djram+9h	;Disk Jockey 2D track zero seek
djtrk	equ	djram+0ch	;Disk Jockey 2D track seek routine
djsec	equ	djram+0fh	;Disk Jockey 2D set sector routine
djdma	equ	djram+012h	;Disk Jockey 2D set DMA address
djread	equ	djram+15h	;Disk Jockey 2D read routine
djwrite	equ	djram+18h	;Disk Jockey 2D write routine
djsel	equ	djram+1bh	;Disk Jockey 2D select drive routine
djtstat	equ	djram+21h	;Disk Jockey 2D terminal status routine
djstat	equ	djram+27h	;Disk Jockey 2D status routine
djerr	equ	djram+2ah	;Disk Jockey 2D error, flash led
djden	equ	djram+2dh	;Disk Jockey 2D set density routine
djside	equ	djram+30h	;Disk Jockey 2D set side routine

.comment \
*****************************************************************
*								*
* CP/M system equates. If reconfiguration of the CP/M system	*
* is being done, the changes can be made to the following	*
* equates.							*
*								*
*****************************************************************
\
msize	equ	52		;Memory size of target CP/M
bias	equ	(msize-20)*1024	;Memory offset from 20k system
ccp	equ	2d00h+bias	;Console command processor
	; 2D00H = location of CCP in 16k CP/M 1.4 and hence use that as their zero-bias offset
	; 	 Note: The ZCCP file uses CCP = AD00H which is based on a 52k CP/M = 2D00H + (52k - 20k = 32k = 0x800)
	;	This then implies that CCP+BDOS+CBIOS = 8960 bytes in total length and hence the CBIOS = D00H (3328) in length 
	;		rather than the default 0600H.
	;	This 2D00H is also defined in ABOOT#.asm
	; 3400H = location of CCP in 24k CP/M 2.2. The CP/M manual talks about CP/M being loaded to memory at 3400H
	;	This implies a maximum CBIOS size of 1536 bytes or 600H bytes which is the default/expected size for CP/M 2.2.
	; 3500H = it usually indicates a non-standard BIOS that has moved the CCP to make room for larger disk buffers or a "Cold 	
	; 	Start Loader." Or, it is 100H for the boot sector padding. Or, 100H has been added between the TPA and CCP for memory protection. 
	; In another more complex Morrow CBIOS (with HD support) they properly calculate CCP based on the actual size of the BIOS
	;
	; ### I have a feeling that they did not update the 2D00H to 3400H when migrating their 1.4 BIOS to 2.2! Hence, there may be
	;	a lot of wasted space (D00H instead of 600H for the BIOS).

bdos	equ	ccp+800h	;BDOS address
bios	equ	ccp+1600h	;CBIOS address
cdisk	equ	4		;Address of last logged disk
buff	equ	80h		;Default buffer address
tpa	equ	100h		;Transient memory
intioby	equ	0		;Initial IOBYTE
iobyte	equ	3		;IOBYTE location
wbot	equ	0		;Warm boot jump address
entry	equ	5		;BDOS entry jump address

.comment \
*****************************************************************
*								*
* The following are internal Cbios equates. Most are misc. 	*
* constants.							*
*								*
*****************************************************************
\
retries	equ	10		;Max retries on disk i/o before error
acr	equ	0dh		;A carriage return
alf	equ	0ah		;A line feed
aetx	equ	3		;A ETX char
aack	equ	6		;A ACK char
clear	equ	0ch		;Clear screen char on ADM3 terminal
maxdisk	equ	4		;Maximum # of disk drives
dblsid	equ	8		;Side bit from controller

.comment \
*****************************************************************
*								*
* The jump table below must remain in the same order, the 	*
* routines may be changed, but the function executed must be	*
* the same.							*
*								*
*****************************************************************
\
.phase		bios		;CBIOS starting address
.z80				;use Z80 code

	jp	cboot		;Cold boot entry point
wboote:	jp	wboot		;Warm boot entry point
	jp	const		;Console status routine
	jp	conin		;Console input
cout:	jp	conout		;Console output
	jp	list		;List device output
	jp	punch		;Punch device output
	jp	reader		;Reader device input
	jp	home		;Home drive
	jp	setdrv		;Select disk
	jp	settrk		;Set track
	jp	setsec		;Set sector
	jp	setdma		;Set DMA address
	jp	read		;Read the disk
	jp	write		;Write the disk
	jp	listst		;List device status
	jp	sectran		;Sector translation
djdrv:	jp	djsel		;Hook for SINGLE.COM program

.comment \
*****************************************************************
*								*
* Signon message output during cold boot.			*
*								*
*****************************************************************
\
prompt:	db	acr,alf
	db	'   ',1bh,34h,'** '
	db	'0'+msize/10		;CP/M memory size
	db	'0'+(msize mod 10)
	db	'k ZCP/M '		;CP/M version number
	db	cpmrev/10+'0'
	db	'.'
	db	(cpmrev mod 10)+'0'
	db	', Cbios '
	db	revnum/10+'0','.'	;Cbios revision number
	db	revnum mod 10+'0'
	db	', For TT DJ 2D '
	db	'@ '

	db	'D000H **',1bh,35h,acr,alf,0

.comment \
	if	origin/1000h gt 0Ah	;Controller origin (HEX)
	db	(origin/1000h)-0Ah+41h
	else
	db	origin/1000h+30h
	endif

	if	(origin/100h and 0fh) gt 10
	db	(origin/100h and 0fh)-10+65
	else
	db	(origin/100h and 0fh)+48
	endif
	db	'00H.'
	db	acr,0
\

.comment \
*****************************************************************
*								*
* Utility routine to output the message pointed at by H&L,	*
* terminated with a null.					*
*								*
*****************************************************************
\
message:ld	a,(hl)
	inc	hl
	and	a
	ret	z
	push	hl
	ld	c,a
	call	cout
	pop	hl
	jr	message

.comment \
*****************************************************************
*								*
* Cboot is the cold boot loader. All of CP/M has been loaded in	*
* when control is passed here.					*
*								*
*****************************************************************
\
cboot:	ld	sp,tpa		;Set up stack
	call	tinit		;Initialize the terminal

	ld	hl,prompt	;Prep for sending signon message
	call	message		;Send the prompt
	xor	a		;Select disk A
	ld	(cpmdrv),a
	ld	(cdisk),a

.comment \
*****************************************************************
*								*
* Gocpm is the entry point from cold boots, and warm boots. It	*
* initializes some of the locations in page 0, and sets up the	*
* initial DMA address (80h).					*
*								*
*****************************************************************
\
gocpm:	call	time		; send out the time
	ld	hl,buff		;Set up initial DMA address
	call	setdma
	ld	a,0c3h		;Initialize jump to warm boot
	ld	(wbot),a
	ld	(entry),a	;Initialize jump to BDOS
	ld	hl,wboote	;Address in warm boot jump
	ld	(wbot+1),hl
	ld	hl,bdos+6	;Address in BDOS jump
	ld	(entry+1),hl
	xor	a		;A <- 0
	ld	(bufsec),a	;Disk Jockey buffer empty
	ld	(bufwrtn),a	;Set buffer not dirty flag
	ld	a,(cdisk)	;Jump to CP/M with currently selected disk in C
	ld	c,a
	ld	de,cmndbeg	;Beginning of initial command
	ld	hl,ccp+8		;Command buffer
	ld	a,cmndend-cmndbeg+1 ;Length of command
	ld	(ccp+7),a
	push	bc		;save drive #
	ld	c,a		;command length in 'BC'
	ld	b,0
	call	movlop
	pop	bc
	ld	a,(cwflg)
	and	a
	ld	a,(autoflg)
	jr	z,cldbot
	rra
cldbot:	rra
	jp	c,ccp
	jp	ccp+3		;Enter CP/M

cwflg:	db	0		;Cold/warm boot flag

.comment \
*****************************************************************
*								*
* The following byte determines if an initial command is to be	*
* given to CP/M on warm or cold boots. The value of the byte is	*
* used to give the command to CP/M:				*
*								*
* 0 = never give command.					*
* 1 = give command on cold boots only.				*
* 2 = give the command on warm boots only.			*
* 3 = give the command on warm and cold boots.			*
*								*
*****************************************************************
\
autoflg:db	0		;Auto command feature

.comment \
*****************************************************************
*								*
* If there is a command inserted here, it will be given if the	*
* auto feature is enabled.					*
*	For Example:						*
*								*
*	cmndbeg	db	'MBASIC MYPROG'				*
*	cmndend	db	0					*
*								*
* will execute microsoft basic, and mbasic will execute the	*
* "MYPROG" basic program.					*
*								*
*****************************************************************
\
cmndbeg:db	''		;Initial command goes here
cmndend:db	0

.comment \
*****************************************************************
*								*
* Wboot loads in all of CP/M except the CBIOS, then initializes	*
* system parameters as in cold boot. See the Cold Boot Loader	*
* listing for exactly what happens during warm and cold boots.	*
*								*
*****************************************************************
\
wboot:	ld	sp,tpa		;Set up stack pointer
	ld	a,1

wflg	equ	$-1		;Test if beginning or
	and	a		;	ending a warm boot
	ld	a,1
	ld	(wflg),a
	ld	(cwflg),a	;Set cold/warm boot flag
	jr	z,gocpm		
	call	djhome		;Home the head to track 0
	xor	a
	ld	(wflg),a
	ld	c,a
	call	djdrv		;Select drive A
	ld	c,0		;Select single density
	call	djden
	ld	c,0		;Select side 0
	call	djside
	ld	a,15		;Initialize the sector to read
	ld	(newsec),a
	ld	hl,ccp-100h	;And the DMA address
	ld	(newdma),hl
	call	warmlod		;Read in CP/M
	ld	bc,ccp+500h	;Load address for rest of warm boot
	call	djdma
	ld	c,8
	call	djsec
	call	warmrd
	jp	ccp+503h

warmlod:ld	a,15		;Previous sector

newsec	equ	$-1
	inc	a		;Update the previous sector
	inc	a
	cp	27		;Was it the last ?
	jr	c,nowrap
	sub	9		;Yes
	cp	19
	ret	z
	ld	hl,(newdma)
	ld	de,-480h
	add	hl,de
	ld	(newdma),hl
nowrap:	ld	(newsec),a	;Save the new sector to read
	ld	c,a
	call	djsec
	ld	hl,ccp-100h	;Get the previous DMA address

newdma	equ	$-2
	ld	de,100h		;Update the DMA address
	add	hl,de
	ld	(newdma),hl	;Save the DMA address
	ld	b,h
	ld	c,l
	call	djdma		;Set the DMA address
	call	warmrd
	jr	warmlod

warmrd:	ld	bc,retries*100h+0;Maximum # of errors
wrmread:push	bc
	call	djtrk		;Set the track
	call	djread		;Read the sector
	pop	bc
	ret	nc		;Continue if successful
	djnz	wrmread		;keep trying
	jp	djerr

.comment \
*****************************************************************
*								*
* Setsec just saves the desired sector to seek to until an	*
* actual read or write is attempted.				*
*								*
*****************************************************************
\
setsec:	ld	a,c		;Save the sector number
	ld	(cpmsec),a	;CP/M sector #
	ret

.comment \
*****************************************************************
*								*
* Setdma saves the DMA address for the data transfer.		*
*								*
*****************************************************************
\
setdma:	ld	h,b		;hl <- bc
	ld	l,c
	ld	(cpmdma),hl	;CP/M dma address
	ret

.comment \
*****************************************************************
*								*
* Home is translated into a seek to track zero.			*
*								*
*****************************************************************
\
home:	ld	c,0		;Track to seek to

.comment \
*****************************************************************
*								*
* Settrk saves the track # to seek to. Nothing is done at this	*
* point, everything is deffered until a read or write.		*
*								*
*****************************************************************
\
settrk:	ld	a,c		;A <- track #
	ld	(cpmtrk),a	;CP/M track #
	ret

.comment \
*****************************************************************
*								*
* Sectran translates a logical sector # into a physical sector	*
* #.								*
*								*
*****************************************************************
\
sectran:inc	bc
	push	de		;Save table address
	push	bc		;Save sector #
	call	getdpb		;Get DPB address into HL
	ld	a,(hl)		;Get # of CP/M sectors/track
	or	a		;Clear cary
	rra			;Divide by two
	sub	c
	push	af		;Save adjusted sector
	jp	m,sidetwo
sidea:	pop	af		;Discard adjusted sector
	pop	bc		;Restore sector requested
	pop	de		;Restor address of xlt table
sideone:ex	de,hl		;hl <- &(translation table)
	add	hl,bc		;bc = offset into table
	ld	l,(hl)		;hl <- physical sector
	ld	h,0
	ret

sidetwo:ld	bc,15		;Offset to side bit
	add	hl,bc
	bit	3,(hl)		;test for double sided
	jr	z,sidea		;Media is only single sided
	pop	af		;Retrieve adjusted sector
	pop	bc
	cpl			;Make sector request positive
	inc	a
	ld	c,a		;Make new sector the requested sector
	pop	de
	call	sideone
	set	7,l		;side two bit, and sector
	ret

.comment \
*****************************************************************
*								*
* Setdrv selects the next drive to be used in read/write	*
* operations. If the drive has never been selected before, a	*
* parameter table is created which correctly describes the 	*
* diskette currently in the drive. Diskettes can be of four	*
* different sector sizes:					*
*	1) 128 bytes single density.				*
*	2) 256 bytes double density.				*
*	3) 512 bytes double density.				*
*	4) 1024 bytes double density.				*
*								*
*****************************************************************
\
setdrv:	ld	a,c		;Save the drive #
	ld	(cpmdrv),a
	cp	maxdisk		;Check for a valid drive #
	jr	nc,zret		;Illegal drive #
	bit	0,e		;test if drive ever logged in before
	jr	nz,STDRV1	;Bit 0 of E = 0 -> Never selected before
	ld	a,1		;Select sector 1 of track 1
	ld	(truesec),a
	ld	(cpmtrk),a
	call	fill		;Flush buffer and refill
	jr	c,zret		;Test for error return
	call	djstat		;Get status on current drive
	and	0ch		;Strip off unwanted bits
	push	af		;Used to select a DPB
	rra
	ld	hl,xlts		;Table of XLT addresses
	ld	e,a
	ld	d,0
	add	hl,de
	push	hl		;Save pointer to proper XLT
	call	getdpb		;Get DPH pointer into DE
	ex	de,hl		;
	pop	de
	ld	bc,02		;number of bytes to move
	call	movlop		;Move the address of XLT
	ld	de,8		;Offset to DPB pointer
	add	hl,de		;HL <- &DPH.DPB
	push	hl
	ld	hl,(origin+7)	;Get address of DJ terminal out routine
	inc	hl		;Bump to look at address of
				;	uart status location
	ld	a,(hl)		
	xor	3		;Adjust for proper rev DJ
	ld	l,a
	ld	h,origin/100h+3	;(origin+300h)/100h
	bit	3,(hl)		;check double sided bit
	ld	de,DS128	;Base for single sided DPB's
	jr	nz,sideok
	ld	de,DD128	;Base of double sided DPB's
sideok:	ex	de,hl		;HL <- DBP base, DE <- &DPH.DPB
	pop	de		;Restore DE (pointer into DPH)
	pop	af		;Offset to correct DPB
	rla
	rla
	ld	c,a
	ld	b,0
	add	hl,bc
	ex	de,hl		;Put DPB address in DPH
	ld	(hl),e
	inc	hl
	ld	(hl),d
STDRV1:call	getdpb		;Get address of DPB in HL
	ld	bc,15		;Offset to sector size
	add	hl,bc
	ld	a,(hl)		;Get sector size
	and	7h
	ld	(secsiz),a
	ld	a,(hl)
	rra
	rra
	rra
	rra
	and	0fh
	ld	(secpsec),a
	ex	de,hl		;HL <- DPH
	ret

zret:	ld	hl,0		;Seldrv error exit
	ret

.comment \
*****************************************************************
*								*
* Getdpb returns HL pointing to the DPB of the currently	*
* selected drive, DE pointing to DPH.				*
*								*
*****************************************************************
\
getdpb:	ld	a,(cpmdrv)	;Get drive #
	ld	l,a		;Form offset
	ld	h,0
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	ld	de,dpzero	;Base of DPH's 
	add	hl,de
	push	hl		;Save address of DPH
	ld	de,10		;Offset to DPB
	add	hl,de
	ld	a,(hl)		;Get low byte of DPB address
	inc	hl
	ld	h,(hl)		;Get low byte of DPB
	ld	l,a
	pop	de
	ret

.comment \
*****************************************************************
*								*
* Xlts is a table of address that point to each of the xlt	*
* tables for each sector size.					*
*								*
*****************************************************************
\
xlts:	dw	xlt128		;Xlt for 128 byte sectors
	dw	xlt256		;Xlt for 256 byte sectors
	dw	xlt512		;Xlt for 512 byte sectors
	dw	xlt124		;Xlt for 1024 byte sectors

.comment \
*****************************************************************
*								*
* Write routine moves data from memory into the buffer. If the	*
* desired CP/M sector is not contained in the disk buffer, the	*
* buffer is first flushed to the disk if it has ever been	*
* written into, then a read is performed into the buffer to get	*
* the desired sector. Once the correct sector is in memory, the	*
* buffer written indicator is set, so the buffer will be	*
* flushed, then the data is transferred into the buffer. 	*
*								*
*****************************************************************
\
write:	ld	a,c		;Save write command type
	ld	(writtyp),a
	ld	a,1		;Set write command
	jr	reado

.comment \
*****************************************************************
*								*
* Read routine to buffer data from the disk. If the sector 	*
* requested from CP/M is in the buffer, then the data is simply	*
* transferreä froí thå buffeò tï thå desireä dma address. If	*
* the buffer does not contain the desired sector, the buffer is	*
* flushed to the disk if it has ever been written into, then	*
* filled with the sector from the disk that contains the	*
* desired CP/M sector.						*
*								*
*****************************************************************
\
read:	xor	a		;Set the command type to read
reado:	ld	(rdwr),a	;Save command type

.comment \
*****************************************************************
*								*
* Redwrt calculates the physical sector on the disk that	*
* contains the desired CP/M sector, then checks if it is the	*
* sector currently in the buffer. If no match is made, the	*
* buffer is flushed if necessary and the correct sector read	*
* from the disk.						*
*								*
*****************************************************************
\
redwrt:	ld	b,0		;The 0 is modified to contain the log2
secsiz	equ	$-1		;	of the physical sector size/128
				;	on the currently selected disk.
	ld	a,(cpmsec)	;Get the desired CP/M sector #
	push	af		;Temporary save
	and	80h		;Save only the side bit
	ld	c,a		;Remember the side
	pop	af		;Get the sector back
	and	7fh		;Forget the side bit
	dec	a		;Temporary adjustment
divloop:dec	b		;Update repeat count
	jr	z,divdone
	or	a		;Clear the cary flag
	rra			;Divide the CP/M sector # by the size
				;	of the physical sectors
	jr	divloop		;
divdone:inc	a
	or	c		;Restore the side bit
	ld	(truesec),a	;Save the physical sector number
	ld	hl,cpmdrv	;Pointer to desired drive,track, and sector
	ld	de,bufdrv	;Pointer to buffer drive,track, and sector
	ld	b,4		;Count loop
dtslop:	dec	b		;Test if done with compare
	jr	z,move		;Yes, match. Go move the data
	ld	a,(de)		;Get a byte to compare
	cp	(hl)		;Test for match
	inc	hl		;Bump pointers to next data item
	inc	de
	jr	z,dtslop	;Match, continue testing

.comment \
*****************************************************************
*								*
* Drive, track, and sector don't match, flush the buffer if	*
* necessary and then refill.					*
*								*
*****************************************************************
\
	call	fill		;Fill the buffer with correct physical sector
	ret	c		;No good, return with error indication

.comment \
*****************************************************************
*		 						*
* Move has been modified to cause either a transfer into or out	*
* the buffer.							*
*								*
*****************************************************************
\
move:	ld	a,(cpmsec)	;Get the CP/M sector to transfer
	dec	a		;Adjust to proper sector in buffer
	and	0		;Strip off high ordered bits
secpsec	equ	$-1		;The 0 is modified to represent the # of
				;	CP/M sectors per physical sectors
	ld	l,a		;Put into HL
	ld	h,0
	add	hl,hl		;Form offset into buffer
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	ld	de,buffer	;Beginning address of buffer
	add	hl,de		;Form beginning address of sector to transfer
	ex	de,hl		;DE = address in buffer
	ld	hl,0		;Get DMA address, the 0 is modified to
				;	contain the DMA address
cpmdma	equ	$-2
	ld	a,0		;The zero gets modified to contain
				;	a zero if a read, or a 1 if write
rdwr	equ	$-1
	and	a		;Test which kind of operation
	jr	nz,into		;Transfer data into the buffer
outof:	call	mover
	xor	a
	ret

into:	ex	de,hl		;
	call	mover		;Move the data, HL = destination
				;	DE = source
	ld	a,1
	ld	(bufwrtn),a	;Set buffer written into flag
	ld	a,0		;Check for directory write

writtyp	equ	$-1
	dec	a
	ld	a,0
	ld	(writtyp),a	;Set no directory write
	ret	nz		;No error exit

.comment \
*****************************************************************
*								*
* Flush writes the contents of the buffer out to the disk if	*
* it has ever been written into.				*
*								*
*****************************************************************
\
flush:	ld	a,0		;The 0 is modified to reflect if
				;	the buffer has been written into
bufwrtn	equ	$-1
	and	a		;Test if written into
	ret	z		;Not written, all done
	ld	hl,djwrite	;Write operation

.comment \
*****************************************************************
*								*
* Prep prepares to read/write the disk. Retries are attempted.	*
* Upon entry, H&L must contain the read or write operation	*
* address.							*
*								*
*****************************************************************
\
prep:	xor	a		;Reset buffer written flag
	ld	(bufwrtn),a
	ld	(retryop),hl		;Set up the read/write operation
	ld	b,retries	;Maximum number of retries to attempt
retrylp:push	bc		;Save the retry count
	ld	a,(bufdrv)	;Get drive number involved in the operation
	ld	c,a
	call	djdrv		;Select the drive
	ld	a,(buftrk)
	and	a		;Test for track zero
	ld	c,a
	push	bc
	call	z,djhome		;Home the drive if track 0
	pop	bc		;Restore track #
	call	djtrk		;Seek to proper track
	ld	a,(bufsec)	;Get sector involved in operation
	push	af		;Save the sector #
	rlca			;Bit 0 of A equals side #
	and	1		;Strip off unnecessary bits
	ld	c,a		;C <- side #
	call	djside		;Select the side
	pop	af		;A <- sector #
	and	7fh		;Strip off side bit
	ld	c,a		;C <- sector #
	call	djsec		;Set the sector to transfer
	ld	bc,buffer	;Set the DMA address
	call	djdma
	call	djread		;The read operation is modified to write
retryop	equ	$-2
	pop	bc		;Restore the retry counter
	ld	a,0		;No error exit status
	ret	nc		;Return no error
	dec	b		;Update the retry counter
	scf			;Assume retry count expired
	ld	a,0ffh		;Error return
	ret	z
	jr	retrylp		;Try again

.comment \
*****************************************************************
*								*
* Fill fills the buffer with a new sector from the disk.	*
*								*
*****************************************************************
\
fill:	call	flush		;Flush buffer first
	ret	c		;Check for error
	ld	de,cpmdrv	;Update the drive, track, and sector
	ld	hl,bufdrv	
	ld	bc,03		;number of bytes to move
	call	movlop		;Copy the data
	ld	hl,djread
	jr	prep		;Select drive, track, and sector.
				;	Then read the buffer

.comment \
*****************************************************************
*								*
* Mover moves 128 bytes of data. Source pointer in DE, Dest	*
* pointer in HL.						*
*								*
*****************************************************************
\
mover:	ld	bc,128
movlop:	ex	de,hl
	ldir
	ex	de,hl
	ret

;*****************************************************************
;*								*
;* Modified console input and output routines.			*
;*								*
;*****************************************************************

exdyin	equ	0e009h		;Exidy input
exdyot	equ	0e00ch		;Exidy output

expar1	equ	0e033h		;Exidy centronics driver w/o lf
expar2	equ	0e036h		;Exidy centronics driver with lf
kbstat	equ	0e03fh		;Exidy keyboard status

cstty:	jp	kbstat

cotty:	ld	a,c
	cp	01ah
	jr	nz,notclr
	ld	a,0ch
notclr:	cp	07h		; bell?
	jp	z,bell
	jp	exdyot

citty:	call	exdyin
	jr	z,citty
	cp	093h
	jp	z,0e003h
;	cp	07fh
;	jr	nz,notbs
;	ld	a,08h
notbs:	ret

colpt:	ld	a,(0003)	; get I/O byte
	and	0c0h
	ld	a,c
	jp	z,expar1	; printer driver w/o lf
	cp	080h		; > 127?
	jp	c,expar2
setbit:	ld	a,0cfh		; no auto line feed,bit 7=on
	out	(base+2),a
	ld	a,c
	call	expar2
	ld	a,8fh		; no auto line feed, bit 7=on
	out	(base+2),a
	ret

.comment \
*****************************************************************
*								*
* const: get the status for the currently assigned console	*
*	 device. The console device can be gotten from iobyte,	*
*	 then a jump to the correct console status routine is	*
*	 performed.						*
*								*
*****************************************************************
\
const:	jr	cstty

.comment \
*****************************************************************
*								*
* csreader: if the console is assigned to the reader then a	*
*	    jump will be made here, where another jump will	*
*	    occur to the correct reader status.			*
*								*
*****************************************************************
\
csreadr: jr	citty

.comment \
*****************************************************************
*								*
* conin: take the correct jump for the console input routine.	*
*	 The jump is based on the two least significant bits of	*
*	 iobyte.						*
*								*
*****************************************************************
\
conin:	call	flush		;Flush the disk buffer
	jr	citty

.comment \
*****************************************************************
*								*
* conout: take the proper branch address based on the two least	*
*	  significant bits of iobyte.				*
*								*
*****************************************************************
\
conout:	push	bc		;Save the character
	call	flush		;Flush the disk buffer
	pop	bc		;Restore the character
	jr	cotty

.comment \
*****************************************************************
*								*
* reader: select the correct reader device for input. The	*
*	  reader is selected from bits 2 and 3 of iobyte.	*
*								*
*****************************************************************
\
reader:	jr	citty

.comment \
*****************************************************************
*								*
* punch: select the correct punch device. The selection comes	*
*	 from bits 4&5 of iobyte.				*
*								*
*****************************************************************
\
punch:	jr	cotty

.comment \
*****************************************************************
*								*
* list: select a list device based on bits 6&7 of iobyte	*
*								*
*****************************************************************
\
list:	jr	colpt

;*****************************************************************
;*								*
;* listst: get the status for the list device.  Note that the	*
;* list device used is the Exidy Parallel Port.               	*
;*								*
;*****************************************************************

	.8080
listst:	in	0ffh
	ani	080h		; check bit 7
	cpi	080h		; bit 7=1 = not ready
	jnz	ready
	mvi	a,00H
	ret			;return A=0, if not ready
ready:	mvi	a,0FFH		;return A=0FFH, if ready 
	ret

; ************************************************************
;
; When a bell is send out to the CP/M Console (the Sorcerer
; video section) this bell routine is called. It just creates
; a noise on the S-100 card (transistor - speaker setup).
;
; ************************************************************

BELLPRT EQU	0C2H		; Speaker noise port

BELL:	PUSH	PSW		; Send Bell tone to 
	PUSH	B		; xsistor/speaker hardware
	PUSH	H
	MVI	B,06
LPP5:	PUSH	B
	MVI	L,0FFH
	MVI	C,08
LPP3:	MOV	B,L
	MVI	A,01FH
	OUT	BELLPRT
LPP1:	DCR	B
	JNZ	LPP1
	MOV	B,L
	MVI	A,0FH
	OUT	BELLPRT
LPP2:	DCR	B
	JNZ	LPP2
	DCR 	C
	JNZ	LPP3
	POP	B
	DCR	B
	JNZ	LPP5
	POP	H
	POP	B
	POP	PSW
	RET

	.z80

.comment \
*****************************************************************
*								*
* Tinit can be modified for different I/O setups.		*
*								*
*****************************************************************
\
base	equ	0c0h		; parrallel I/O bd.

tinit:	ld	a,080h
	out 	(base+3),a	; init 8255's
	out	(base+7),a
	xor	a
	out	(base+1),a
	ld	a,0fh
	out	(base+2),a

	ld	c,clear		;Initialize the terminal routine
	ld	a,intioby	;Initialize IOBYTE
	ld	(iobyte),a
	jp	cout

; ************************************************************
;
; Clock routines for MM58167 clock chip located at BASE+16-38
;
; ************************************************************


TIME:	exx
	ld	hl,TIMEBUF+3	;address of time area
	IN	a,(BASE+20)	;read hours
	CALL	CONVERT		;place in buffer
	inc	hl
	IN	a,(BASE+19)	;read minutes
	CALL	CONVERT		;place in buffer
	inc	hl
	IN	a,(BASE+18)	;read seconds
	CALL	CONVERT		;place in buffer
	LD	hl,timebuf
	call	message
	exx
	ret

CONVERT:PUSH	AF		; convert # in A to 2 ascII 
	AND	0F0H
	RRCA
	RRCA
	RRCA
	RRCA
	CALL	HCHOT2		; form ASCII
	POP	AF		; get back char
	AND	0FH		; only right half
HCHOT2:	CP	0AH		; need leter?
	JR	C,HCHOT3		; no
	ADD	a,'A'-03AH	; adjust for A-F
HCHOT3: ADD	a,030H		; make ASCII
	ld	(hl),a		; store away
	inc	hl
	ret

TIMEBUF:defb	0DH,0AH,'{00:00:00}',0

.comment \
*****************************************************************
*								*
* Xlt tables (sector skew tables) for CP/M 2.0. These tables	*
* define the sector translation that occurs when mapping CP/M	*
* sectors to physical sectors on the disk. There is one skew	*
* table for each of the possible sector sizes. Currently the	*
* tables are located on track 0 sectors 6 and 8. They are	*
* loaded into memory in the Cbios ram by the cold boot routine.	*
*								*
*****************************************************************
\
xlt128:	db	0
	db	1,7,13,19,25
	db	5,11,17,23
	db	3,9,15,21
	db	2,8,14,20,26
	db	6,12,18,24
	db	4,10,16,22

xlt256:	db	0
	db	1,2,19,20,37,38
	db	3,4,21,22,39,40
	db	5,6,23,24,41,42
	db	7,8,25,26,43,44
	db	9,10,27,28,45,46
	db	11,12,29,30,47,48
	db	13,14,31,32,49,50
	db	15,16,33,34,51,52
	db	17,18,35,36

xlt512:	db	0
	db	1,2,3,4,17,18,19,20
	db	33,34,35,36,49,50,51,52
	db	5,6,7,8,21,22,23,24
	db	37,38,39,40,53,54,55,56
	db	9,10,11,12,25,26,27,28
	db	41,42,43,44,57,58,59,60
	db	13,14,15,16,29,30,31,32
	db	45,46,47,48

xlt124:	db	0
	db	1,2,3,4,5,6,7,8
	db	25,26,27,28,29,30,31,32
	db	49,50,51,52,53,54,55,56
	db	9,10,11,12,13,14,15,16
	db	33,34,35,36,37,38,39,40
	db	57,58,59,60,61,62,63,64
	db	17,18,19,20,21,22,23,24
	db	41,42,43,44,45,46,47,48

.comment \
*****************************************************************
*								*
* Each of the following tables describes a diskette with the	*
* specified characteristics. The tables are currently stored	*
* on track 0 sector 13. They are read into memory by the GOCPM	*
* routine in the CBIOS for CP/M ver 2.0. 			*
*								*
*****************************************************************


*****************************************************************
*								*
* The following DPB defines a  diskette for 128 byte sectors,	*
* single density, and single sided.				*
*								*
*****************************************************************
\
DS128:dw	26		;CP/M sectors/track
	db	3		;BSH
	db	7		;BLM
	db	0		;EXM
	dw	242		;DSM
	dw	63		;DRM
	db	0c0h		;AL0
	db	0		;AL1
	dw	16		;CKS
	dw	2		;OFF
	db	1h		;16*((#cpm sectors/physical sector) -1) +
				;log2(#bytes per sector/128) + 1 +
				;8 if double sided.
.comment \
*****************************************************************
*								*
* The following DPB defines a diskette for 256 byte sectors,	*
* double density, and single sided.				*
*								*
*****************************************************************
\
DS256:dw	52		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	242		;DSM
	dw	127		;DRM
	db	0c0h		;AL0
	db	0		;AL1
	dw	32		;CKS
	dw	2		;OFF
	db	12h		;16*((#cpm sectors/physical sector) -1) +
				;log2(#bytes per sector/128) + 1 +
				;8 if double sided.

.comment \
*****************************************************************
*								*
* The following DPB defines a diskette as 512 byte sectors,	*
* double density, and single sided.				*
*								*
*****************************************************************
\
DS512:dw	60		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	280		;DSM
	dw	127		;DRM
	db	0c0h		;AL0
	db	0		;AL1
	dw	32		;CKS
	dw	2		;OFF
	db	33h		;16*((#cpm sectors/physical sector) -1) +
				;log2(#bytes per sector/128) + 1 +
				;8 if double sided.

.comment \
*****************************************************************
*								*
* The following DPB defines a diskette as 1024 byte sectors,	*
* double density, and single sided.				*
*								*
*****************************************************************
\
DS1024:dw	64		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	299		;DSM
	dw	127		;DRM
	db	0c0h		;AL0
	db	0		;AL1
	dw	32		;CKS
	dw	2		;OFF
	db	74h		;16*((#cpm sectors/physical sector) -1) +
				;log2(#bytes per sector/128) + 1 +
				;8 if double sided.

.comment \
*****************************************************************
*								*
* The following DPB defines a diskette for 128 byte sectors,	*
* single density, and double sided.				*
*								*
*****************************************************************
\
DD128:dw	52		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	1		;EXM
	dw	242		;DSM
	dw	127		;DRM
	db	0c0h		;AL0
	db	0		;AL1
	dw	32		;CKS
	dw	2		;OFF
	db	9h

.comment \
*****************************************************************
*								*
* The following DPB defines a diskette as 256 byte sectors,	*
* double density, and double sided.				*
*								*
*****************************************************************
\
DD256:dw	104		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	486		;DSM
	dw	255		;DRM
	db	0f0h		;AL0
	db	0		;AL1
	dw	64		;CKS
	dw	2		;OFF
	db	1ah

.comment \
*****************************************************************
*								*
* The following DPB defines a diskette as 512 byte sectors,	*
* double density, and double sided.				*
*								*
*****************************************************************
\
DD512:dw	120		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	561		;DSM
	dw	255		;DRM
	db	0f0h		;AL0
	db	0		;AL1
	dw	64		;CKS
	dw	2		;OFF
	db	3bh

.comment \
*****************************************************************
*								*
* The following DPB defines a diskette as 1024 byte sectors,	*
* double density, and double sided.				*
*								*
*****************************************************************
\
DD1024:dw	128		;CP/M sectors/track
	db	4		;BSH
	db	15		;BLM
	db	0		;EXM
	dw	599		;DSM
	dw	255		;DRM
	db	0f0h		;AL0
	db	0		;AL1
	dw	64		;CKS
	dw	2		;OFF
	db	7ch

.comment \
*****************************************************************
*								*
* CP/M disk parameter headers, unitialized.			*
*								*
*****************************************************************
\
dpzero:	dw	0		;Address of translation table (filled
				;	in by setdrv)
	dw	0,0,0		;Used by BDOS
	dw	dirbuf		;Address of directory buffer
	dw	0		;Address of DPB (filled in by setdrv)
	dw	csv0		;Directory check vector
	dw	alv0		;Allocation vector

dpone:	dw	0
	dw	0,0,0
	dw	dirbuf
	dw	0
	dw	csv1
	dw	alv1

dptwo:	dw	0
	dw	0,0,0
	dw	dirbuf
	dw	0
	dw	csv2
	dw	alv2

dpthre:	dw	0
	dw	0,0,0
	dw	dirbuf
	dw	0
	dw	csv3
	dw	alv3

.comment \
*****************************************************************
*								*
* Cbios ram locations that don't need initialization.		*
*								*
*****************************************************************
\
cpmsec:	db	0		;CP/M sector #
cpmdrv:	db	0		;CP/M drive #
cpmtrk:	db	0		;CP/M track #
truesec:db	0		;Disk Jockey sector that contains CP/M sector
bufdrv:	db	0		;Drive that buffer belongs to
buftrk:	db	0		;Track that buffer belongs to
bufsec:	db	0		;Sector that buffer belongs to
buffer:	ds	1024		;Maximum size buffer for 1K sectors

alv0:	ds	75		;Allocation vector for drive A
alv1:	ds	75		;Allocation vector for drive B
alv2:	ds	75		;Allocation vector for drive C
alv3:	ds	75		;Allocation vector for drive D
csv0:	ds	64		;Directory check vector for drive A
csv1:	ds	64		;Directory check vector for drive B
csv2:	ds	64		;Directory check vector for drive C
csv3:	ds	64		;Directory check vector for drive D
dirbuf:	ds	128		;Directory buffer

	end
