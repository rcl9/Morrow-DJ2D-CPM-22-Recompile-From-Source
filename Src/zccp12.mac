.COMMENT \

                   *** ZCCP ver 1.01  ***

      (Console Command Processor for Z80 based CP/M 2.+)
                modified by Walter S. Blady

       Modified For RCL9's Exidy Sorcerer Jan. 22, 1983.

             ******** Structure Notes ********

This CPR is divided into a number of major sections.  The 
following is an outline of these sections and the names of
the major routines located therein.

 Section	Function/Routines
 -------	-----------------

   --		Opening Comments, Equates, and Macro Definitions

    0		JMP Table into CPR

    1		Buffers

    2		CPR Starting Modules
		CPR1	CPR	RESTRT	RSTCPR	RCPRNL
		PRNNF

    3		Utilities
		CRLF	CONOUT	CONIN	LCOUT	LSTOUT
		READF	READ	BDOSB	PRINTC	PRINT
		GETDRV	DEFDMA	DMASET	RESET	BDOSJP
		LOGIN	OPENF	OPEN	GRBDOS	CLOSE
		SEARF	SEAR1	SEARN	SUBKIL	DELETE
		RESETUSR GETUSR	SETUSR

     4		CPR Utilities
		SETUD	SETU0D	UCASE	REDBUF	CNVBUF
		BREAK	USRNUM	ERROR	SDELM	ADVAN
		SBLANK	ADDAH	NUMBER	NUMERR	HEXNUM
		DIRPTR	SLOGIN	DLOGIN	COMLOG	SCANER
		CMDSER  

     5		CPR-Resident Commands and Functions
     5a		DIR	DIRPR	DIRSPC   DECOUT   FILLQ
     5b		ERA
     5c		TYPE
     5d		SAVE
     5e		REN
     5f		USER
     5g		DFU
     5h		JUMP
     5i		GO
     5j		COM	CALLPROG	ERRLOG	ERRJMP
     5k		GET	MEMLOAD	PRNLE

Thió versioî addó onå primarù new function tï CCPZ ver 1.1
Thå DIRectorù routinå no÷ reportó thå remaininç disë space, in
addition to it's other duties.  Most of the time this will
eliminate the need to have STAT close at hand.  

	eg. DIR <dr:afn> <option>
	    DIR <dr: option>

	where option is - <all directory files>
			  <system files only>
			  <disk space only>
 
To make room for this feature two options had to be dropped.
The PAGING and LIST options are not supported.  Although these
options were a convenience, they can be easily duplicated
in other ways.  eg. paging with START/STOP scrolling and
list with TYPE ^P.

Several routines have been modified or rewritten in order to 
conserve more space.

The old TYPE routine only buffered 128 bytes per read 
which causeä toï mucè disë actioî - thå ne÷ routinå useó about
half of thå TPA as a buffer.  On some 5 1/4 disk systems, like 
Miropolis, this large buffering ability might be too slow, so
a second buffer option is available - a user specified size.

More than one CCP-resident command can now be typed in and
processed sequentially - like a mini submit file.  

	eg. DIR A: DIR B: TYPE <dr:> <afn>

Walter S. Blady
(416) 231-1898 Toronto.
\

;------------------- modification section ---------------------

FALSE	EQU	0
TRUE	EQU	NOT FALSE

REL	EQU	FALSE	;SET TO TRUE FOR MOVCPM INTEGRATION

BASE	EQU	0	;BASE OF CP/M SYSTEM (SET FOR STANDARD CP/M)

	IF	REL
CPRLOC	EQU	0	;MOVCPM IMAGE
	ELSE

;CPRLOC	EQU	0AD00H		;FILL IN WITH BDOSLOC SUPPLIED VALUE
	; RCL, AD00 is based on a 52k CP/M = 2D00H + (52k - 20k = 32k = 0x8000)
	;
	; RCL - refer to my extended explanation in _CBIOS2.mac
	;

;
; RCL, I replaced the fixed address above with these calculations shared with ABOOT#.ASM, CBIOS2.mac and BDOS22.asm
;
msize	EQU	52		;Memory size of target CP/M
bias	EQU	(msize-20)*1024	;Memory offset from 20k system
CPRLOC	EQU	2d00h+bias	;Console command processor

CPRR	EQU	1100H-CPRLOC	;DDT LOAD OFFSET FOR MORROW DESIGNS
	ENDIF

RAS	EQU	FALSE	;SET TO TRUE IF CPR IS FOR A REMOTE-ACCESS SYSTEM

SUBA	EQU	FALSE 	; Set to TRUE to have $$$.SUB always on A:
			; Set to FALSE to have $$$.SUB on the logged-in drive

CLEVEL3	EQU	TRUE	;ENABLE COMMAND LEVEL 3 PROCESSING

WIDE	EQU	FALSE	;TRUE IF WIDE DIR DISPLAY

MAXUSR	EQU	15 	;MAXIMUM USER NUMBER ACCESSABLE

LBUFF	EQU	TRUE	;TRUE = AUTOMATIC CALCULATION OF 
			;'TYPE' BUFFER SIZE
			;(ABOUT 1/2 THE TPA)

SECOUN	EQU	32	;USER SPECIFIED 'TYPE' BUFFER SIZE
			;(NUMBER OF 128 BYTE SECTORS)

SYSFLG	EQU	'A' 	;FOR DIR COMMAND: LIST $SYS PLUS $DIR

SOFLG	EQU	'S'	;FOR DIR COMMAND: LIST $SYS FILES ONLY

REPORT	EQU	'R'	;FOR DIR COMMAND: REPORT DISK SPACE

SUPRES	EQU	FALSE	;SUPRESSES USER # REPORT FOR USER 0

DEFUSR	EQU	0 	;DEFAULT USER NUMBER FOR COM FILES

SPRMPT	EQU	'$'	;CPR PROMPT INDICATING SUBMIT COMMAND
CPRMPT	EQU	'>'	;CPR PROMPT INDICATING USER COMMAND

NUMBASE	EQU	'H'	;CHARACTER USED TO SWITCH FROM DEFAULT
			; NUMBER BASE

SECTFLG	EQU	'S'	;OPTION CHAR FOR SAVE COMMAND TO SAVE SECTORS

FF	EQU	0CH	;FORM FEED
CR	EQU	0DH	;CARRIAGE RETURN
LF	EQU	0AH	;LINE FEED
TAB	EQU	09H	;TAB

;----------------------- bdos equates -------------------------

WBOOT	EQU	BASE+0000H	;CP/M WARM BOOT ADDRESS
UDFLAG	EQU	BASE+0004H	;USER NUM IN HIGH NYBBLE, DISK IN LOW
BDOS	EQU	BASE+0005H	;BDOS FUNCTION CALL ENTRY PT
TFCB	EQU	BASE+005CH	;DEFAULT FCB BUFFER
TBUFF	EQU	BASE+0080H	;DEFAULT DISK I/O BUFFER
TPA	EQU	BASE+0100H	;BASE OF TPA

COIN	EQU	1		;CONSOLE INPUT
COUT	EQU	2		;CONSOLE OUTPUT
MESOUT	EQU	9		;MESSAGE OUTPUT
RDCON	EQU	10		;READ CONSOLE BUFFER
RESD	EQU	13		;RESET DISK SYSTEM
SELD	EQU	14		;SELECT DISK
OPFI	EQU	15		;OPEN FILE
CLOFI	EQU	16		;CLOSE FILE
SFF	EQU	17		;SEARCH FOR FIRST
SFN	EQU	18		;SEARCH FOR NEXT
DLFI	EQU	19		;DELETE FILE
RSEQU	EQU	20		;READ SEQUENTIAL
CDSK	EQU	25		;RETURN CURRENT DISK
DMAA	EQU	26		;SET DMA
ALLOC	EQU	27		;RETURN ALLOCATION TABLE
DPB	EQU	31		;RETURN DISK PARAMETER BLOCK
USCO	EQU	32		;SET/GET USER CODE


;--------------------------- start ----------------------------
.Z80
.PHASE	CPRLOC

ENTRY	EQU	$

	JP	CPR	; Process potential default command
	JP	CPR1	; Do NOT process potential default command

;----------------- reserved space & buffers -------------------

BUFLEN	EQU	80		;MAXIMUM BUFFER LENGTH

MBUFF:	DB	BUFLEN		;MAXIMUM BUFFER LENGTH
CBUFF:	DB	0		;NUMBER OF VALID CHARS IN COMMAND LINE
CIBUFF:	DB	'               '	;DEFAULT (COLD BOOT) COMMAND
CIBUF:	DB	0			;COMMAND STRING TERMINATOR
	DS	BUFLEN-($-CIBUFF)+1	;TOTAL IS 'BUFLEN' BYTES
	DS	30		;STACK AREA
STACK	EQU	$		;TOP OF STACK

CIBPTR:	DW	CIBUFF		;POINTER TO COMMAND INPUT BUFFER
CIPTR:	DW	CIBUF		;CURRENT POINTER

COMMSG:	DB	'COM'		; FILE TYPE FOR COMMAND

; SUBMIT FILE CONTROL BLOCK

SUBFCB:	IF	SUBA		;IF $$$.SUB ON A:
	DB	1		;DISK NAME SET TO DEFAULT TO DRIVE A:
	ENDIF

	IF	NOT SUBA	;IF $$$.SUB ON CURRENT DRIVE
	DB	0		;DISK NAME SET TO DEFAULT TO CURRENT DRIVE
	ENDIF

	DB	'$$$'		;FILE NAME
	DB	'     '
	DB	'SUB'		;FILE TYPE
	DB	0		;EXTENT NUMBER
	DB	0		;S1
SUBFS2:	DS	1		;S2
SUBFRC:	DS	1		;RECORD COUNT
	DS	16		;DISK GROUP MAP
SUBFCR:	DS	1		;CURRENT RECORD NUMBER

; COMMAND FILE CONTROL BLOCK

FCBDN:	DS	1		;DISK NAME
FCBFN:	DS	8		;FILE NAME
FCBFT:	DS	3		;FILE TYPE
	DS	1		;EXTENT NUMBER
	DS	2		;S1 AND S2
	DS	1		;RECORD COUNT
FCBDM:	DS	16		;DISK GROUP MAP
FCBCR:	DS	1		;CURRENT RECORD NUMBER

; OTHER BUFFERS

;PAGCNT:	DB	NLINES-2	;LINES LEFT ON PAGE
CHRCNT:	DB	0		;CHAR COUNT FOR TYPE
QMCNT:	DB	0		;QUESTION MARK COUNT FOR FCB TOKEN SCANNER

;------------------ CCP resident commands ---------------------

NCHARS	EQU	4		;NUMBER OF CHARS/COMMAND

;4-BYTE COMMAND AND 2-BYTE ADDRESS

CMDTBL:	DB	'DIR '
	DW	DIR
	DB	'TYPE'
	DW	TYPE
	DB	'USER'
	DW	USER
	DB	'DFU '
	DW	DFU

	IF	NOT RAS		;FOR NON-RAS
	DB	'GO  '
	DW	GO
	DB	'ERA '
	DW	ERA
	DB	'SAVE'
	DW	SAVE
	DB	'REN '
	DW	REN
	DB	'GET '
	DW	GET
	DB	'JUMP'
	DW	JUMP
	ENDIF

NCMNDS	EQU	($-CMDTBL)/(NCHARS+2)

;------------------------ start CCPZ --------------------------

;START CPR AND DON'T PROCESS DEFAULT COMMAND STORED

CPR1:	XOR	A		;SET NO DEFAULT COMMAND
	LD	(CBUFF),A

.COMMENT \
START CPR AND POSSIBLY PROCESS DEFAULT COMMAND

NOTE ON MODIFICATION BY RGF: BDOS RETURNS 0FFH IN
ACCUMULATOR WHENEVER IT LOGS IN A DIRECTORY, IF ANY
FILE NAME CONTAINS A '$' IN IT.  THIS IS NOW USED AS
A CLUE TO DETERMINE WHETHER OR NOT TO DO A SEARCH
FOR SUBMIT FILE, IN ORDER TO ELIMINATE WASTEFUL SEARCHES.
\

CPR:	LD	SP,STACK	;RESET STACK
	PUSH	BC
	LD	A,C		;C=USER/DISK NUMBER (SEE LOC 4)
	RRA			;EXTRACT USER NUMBER
	RRA
	RRA
	RRA
	AND	0FH
	LD	E,A		;SET USER NUMBER
	CALL	SETUSR
	CALL	RESET		;RESET DISK SYSTEM
	LD	(RNGSUB),A	;SAVE SUBMIT CLUE FROM DRIVE A:
	POP	BC
	LD	A,C		;C=USER/DISK NUMBER (SEE LOC 4)
	AND	0FH		;EXTRACT DEFAULT DISK DRIVE
	LD	(TDRIVE),A		;SET IT
	JR	Z,NOLOG		;SKIP IF 0...ALREADY LOGGED
	CALL	LOGIN		;LOG IN DEFAULT DISK

	IF	NOT SUBA	;IF $$$.SUB IS ON CURRENT DRIVE
	LD	(RNGSUB),A	;BDOS '$' CLUE
	ENDIF

NOLOG:	LD	DE,SUBFCB	;CHECK FOR $$$.SUB ON CURRENT DISK
RNGSUB	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
	LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS THE RNGSUB FLAG
	OR	A		;SET FLAGS ON CLUE
	CPL			;PREPARE FOR COMING 'CMA'
	CALL	NZ,SEAR1
	CPL			;0FFH IS RETURNED IF NO $$$.SUB, SO COMPLEMENT
	LD	(RNGSUB),A	;SET FLAG (0=NO $$$.SUB)
	LD	A,(CBUFF)	;EXECUTE DEFAULT COMMAND?
	OR	A		;0=NO
	JR	NZ,RS1

; PROMPT USER AND INPUT COMMAND LINE FROM HIM

RESTRT:	LD	SP,STACK	;RESET STACK
	CALL	CRLF		;PRINT PROMPT
	CALL	GETDRV		;CURRENT DRIVE IS PART OF PROMPT
	ADD	A,'A'		;CONVERT TO ASCII A-P
	CALL	CONOUT
	CALL	GETUSR		;GET USER NUMBER

	IF	SUPRES		;IF SUPPRESSING USR # REPORT FOR USR 0
	OR	A
	JR	Z,RS000
	ENDIF

	LD	L,A
	LD	H,0
	CALL	DECOUT

; READ INPUT LINE FROM USER OR $$$.SUB

RS000:	CALL	REDBUF		;INPUT COMMAND LINE FROM USER (OR $$$.SUB)

; PROCESS INPUT LINE

RS1:	
	IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
	CALL	CNVBUF		;CAPITALIZE COMMAND LINE, PLACE ENDING 0,
				; AND SET CIBPTR VALUE
	ENDIF

	CALL	DEFDMA		;SET TBUFF TO DMA ADDRESS
	CALL	GETDRV		;GET DEFAULT DRIVE NUMBER
	LD	(TDRIVE),A	;SET IT
	CALL	SCANER		;PARSE COMMAND NAME FROM COMMAND LINE
	CALL	NZ,ERROR	;ERROR IF COMMAND NAME CONTAINS A '?'
REPET:	LD	DE,RSTCPR	;PUT RETURN ADDRESS OF COMMAND
	PUSH	DE		;ON THE STACK

;IF COMMAND IS CPR RESIDENT JUMP THERE...IF NOT JUMP TO 'COM'

	LD	HL,CMDTBL	;PT TO COMMAND TABLE
	LD	C,NCMNDS	;SET COMMAND COUNTER
CMS1:	LD	DE,FCBFN 	;PT TO STORED COMMAND NAME
	LD	B,NCHARS	;NUMBER OF CHARS/COMMAND (8 MAX)
CMS2:	LD	A,(DE)		;COMPARE AGAINST TABLE ENTRY
	CP	(HL)
	JR	NZ,CMS3		;NO MATCH
	INC	DE		;PT TO NEXT CHAR
	INC	HL
	DJNZ	CMS2		;COUNT DOWN
	LD	A,(DE)		;NEXT CHAR IN INPUT COMMAND MUST BE <SP>
	CP	' '
	JR	NZ,CMS4
	LD	A,(HL)		;FOUND IT:  GET LOW-ORDER PART
	INC	HL		;GET HIGH-ORDER PART
	LD	H,(HL)		;STORE HIGH
	LD	L,A		;STORE LOW
	JP	(HL)		;EXECUTE CPR ROUTINE

CMS3:	INC	HL		;SKIP TO NEXT COMMAND TABLE ENTRY
	DJNZ	CMS3
CMS4:	INC	HL		;SKIP ADDRESS
	INC	HL
	DEC	C		;DECREMENT TABLE ENTRY NUMBER
	JR	NZ,CMS1
	JP	COM

;ENTRY POINT FOR RESTARTING CPR AND LOGGING IN DEFAULT DRIVE

RSTCPR:	CALL	DLOGIN		;LOG IN DEFAULT DRIVE

;ENTRY POINT FOR RESTARTING CPR WITHOUT LOGGING IN DEFAULT DRIVE

RCPRNL:	CALL	SCANER		;EXTRACT NEXT TOKEN FROM COMMAND LINE
	LD	A,(FCBFN)	;GET FIRST CHAR OF TOKEN
	CP	' '		;ANOTHER COMMAND?
	JP	NZ,REPET	;...YES, PROCESS IT.
	JP	RESTRT		;...NO, RESTART CPR

PRNNF:	CALL	PRINTC		;NO FILE MESSAGE
	DB	'No File',0
	RET

.COMMENT \
**** Section 3 ****
I/O UTILITIES

SEND CHAR IN REG A TO CONSOLE AND DON'T CHANGE BC
\

CRLF:	LD	A,CR
	CALL	CONOUT
	LD	A,LF	;FALL THRU TO CONOUT

CONOUT:	PUSH	BC		;SAVE FOR RETURN
	PUSH	AF
	LD	C,COUT		;...NO, SEND TO CONSOLE
LSTOUT:	POP	AF
OUTPUT:	LD	E,A
	PUSH	HL
	CALL	BDOS
	POP	HL
	LD	A,E		;GET BACK CHARACTER
	POP	BC		;...AND RETURN.
	RET

BDOSB:	PUSH	BC		;USED BY VARIOUS BDOS FUNCTIONS
	CALL	BDOS
	POP	BC
	OR	A
	RET

READF:	LD	DE,FCBDN
READ:	LD	C,RSEQU
	JR	BDOSB

CONIN:	LD	C,COIN
	CALL	BDOSB
	JP	UCASE

; PRINT STRING (ENDING IN 0) PTED TO BY RET ADR;START WITH <CRLF>

PRINTC:	PUSH	AF		;SAVE FLAGS
	CALL	CRLF		;NEW LINE
	POP	AF
PRINT:	EX	(SP),HL		;GET PTR TO STRING
	PUSH	AF		;SAVE FLAGS
	CALL	PRIN1		;PRINT STRING
	POP	AF		;GET FLAGS
	EX	(SP),HL		;RESTORE HL AND RET ADR
	RET

; PRINT STRING (ENDING IN 0) PTED TO BY HL

PRIN1:	LD	A,(HL)		;GET NEXT BYTE
	OR	A
	RET	Z
	CALL	CONOUT		;PRINT CHAR
	INC	HL		;PT TO NEXT BYTE
	JR	PRIN1

; BDOS FUNCTION ROUTINES

; RETURN NUMBER OF CURRENT DISK IN A

GETDRV:	LD	C,CDSK		;RETURN CURRENT DISK
	JR	BDOSJP

DEFDMA:	LD	DE,TBUFF 	;SET DMA TO 80H
DMASET:	LD	C,DMAA
	JR	BDOSJP

RESET:	LD	C,RESD		;RESET DRIVES 
BDOSJP:	JP	BDOS

LOGIN:	LD	E,A		;LOG IN DRIVE
	LD	C,SELD
	JR	BDOSJP

OPENF:	XOR	A
	LD	(FCBCR),A
	LD	DE,FCBDN
OPEN:	LD	C,OPFI		;OPEN FILE
GRBDOS:	CALL	BDOS
	INC	A		;SET ZERO FLAG FOR ERROR RETURN
	RET

CLOSE:	LD	C,CLOFI		;CLOSE FILE
	JR	GRBDOS

SEARF:	LD	DE,FCBDN
SEAR1:	LD	C,SFF		;SEARCH FOR FIRST OCCURANCE
	JR	GRBDOS

SEARN:	LD	C,SFN		;SEARCH FOR NEXT OCCURANCE
	JR	GRBDOS

; CHECK FOR SUBMIT FILE IN EXECUTION AND ABORT IT IF SO

SUBKIL:	LD	HL,RNGSUB	;CHECK FOR SUBMIT FILE IN EXECUTION
	LD	A,(HL)
	OR	A		;0=NO
	RET	Z
	LD	(HL),0		;ABORT SUBMIT FILE
	LD	DE,SUBFCB	;DELETE $$$.SUB

DELETE:	LD	C,DLFI		;DELETE FILE
	JR	BDOSJP

; RESET USER NUMBER IF CHANGED

TMPUSR	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
RESETUSR:
	LD	A,0		;<<< SPECIFIED USER NUMBER <<<
	LD	E,A
	JR	SETUSR		;THEN GO SET USER

GETUSR:	LD	E,0FFH		;GET CURRENT USER NUMBER
SETUSR:	LD	C,USCO		;SET USER NUMBER TO VALUE IN E (GET IF E=FFH)
	JR	BDOSJP

;**** Section 4 ****
; CPR UTILITIES

; SET USER/DISK FLAG TO CURRENT USER AND DEFAULT DISK

SETUD:	CALL	GETUSR		;GET NUMBER OF CURRENT USER
	ADD	A,A		;PLACE IT IN HIGH NYBBLE
	ADD	A,A
	ADD	A,A
	ADD	A,A
	LD	HL,TDRIVE	;MASK IN DEFAULT DRIVE NUMBER (LOW NYBBLE)
	OR	(HL)		;MASK IN
	LD	(UDFLAG),A	;SET USER/DISK NUMBER
	RET

; SET USER/DISK FLAG TO USER 0 AND DEFAULT DISK

TDRIVE	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
SETU0D:	LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS TDRIVE
	LD	(UDFLAG),A	;SET USER/DISK NUMBER
	RET

; CONVERT CHAR IN A TO UPPER CASE

UCASE:	CP	61H		;LOWER-CASE A
	RET	C
	CP	7BH		;GREATER THAN LOWER-CASE Z?
	RET	NC
	AND	5FH		;CAPITALIZE
	RET

;INPUT NEXT COMMAND TO CPR
;This routine determines if a SUBMIT file is being processed
;and extracts the command line from it if so or from the user's console

REDBUF:	LD	A,(RNGSUB)	;SUBMIT FILE CURRENTLY IN EXECUTION?
	OR	A		;0=NO
	JR	Z,RB1		;GET LINE FROM CONSOLE IF NOT
	LD	DE,SUBFCB	;OPEN $$$.SUB
	PUSH	DE		;SAVE DE
	CALL	OPEN
	POP	DE		;RESTORE DE
	JR	Z,RB1		;ERASE $$$.SUB IF END OF FILE AND GET CMND
	LD	A,(SUBFRC)	;GET VALUE OF LAST RECORD IN FILE
	DEC	A		;PT TO NEXT TO LAST RECORD
	LD	(SUBFCR),A		;SAVE NEW VALUE OF LAST RECORD IN $$$.SUB
	CALL	READ		;DE=SUBFCB
	JR	NZ,RB1		;ABORT $$$.SUB IF ERROR IN READING LAST REC
	LD	DE,CBUFF 	;COPY LAST RECORD (NEXT SUBMIT CMND) TO CBUFF
	LD	HL,TBUFF 	;  FROM TBUFF
	LD	BC,BUFLEN	;NUMBER OF BYTES
	LDIR
	LD	HL,SUBFS2	;PT TO S2 OF $$$.SUB FCB
	LD	(HL),0		;SET S2 TO ZERO
	INC	HL		;PT TO RECORD COUNT
	DEC	(HL)		;DECREMENT RECORD COUNT OF $$$.SUB
	LD	DE,SUBFCB	;CLOSE $$$.SUB
	CALL	CLOSE
	JR	Z,RB1		;ABORT $$$.SUB IF ERROR
	LD	A,SPRMPT	;PRINT SUBMIT PROMPT
	CALL	CONOUT
	LD	HL,CIBUFF	;PRINT COMMAND LINE FROM $$$.SUB
	CALL	PRIN1
	CALL	BREAK		;CHECK FOR ABORT (ANY CHAR)

	IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
	RET	Z		;IF <NULL> (NO ABORT), RETURN TO CALLER AND RUN
	ENDIF

	IF	NOT CLEVEL3	;IF THIRD COMMAND LEVEL IS NOT PERMITTED
	JR	Z,CNVBUF		;IF <NULL> (NO ABORT), CAPITALIZE COMMAND
	ENDIF

	CALL	SUBKIL		;KILL $$$.SUB IF ABORT
	JP	RESTRT		;RESTART CPR


; INPUT COMMAND LINE FROM USER CONSOLE

RB1:	CALL	SUBKIL		;ERASE $$$.SUB IF PRESENT
	CALL	SETUD		;SET USER AND DISK
	LD	A,CPRMPT	;PRINT PROMPT
	CALL	CONOUT
	LD	C,RDCON		;READ COMMAND LINE FROM USER
	LD	DE,MBUFF
	CALL	BDOS

	IF	CLEVEL3		;IF THIRD COMMAND LEVEL IS PERMITTED
	JP	SETU0D		;SET CURRENT DISK NUMBER IN LOWER PARAMS
	ENDIF

	IF	NOT CLEVEL3	;IF THIRD COMMAND LEVEL IS NOT PERMITTED
	CALL	SETU0D		;SET CURRENT DISK NUMBER IF LOWER PARAMS
				; AND FALL THRU TO CNVBUF
	ENDIF

; CAPITALIZE STRING (ENDING IN 0) IN CBUFF AND SET PTR FOR PARSING

CNVBUF:	LD	HL,CBUFF 	;PT TO USER'S COMMAND
	LD	B,(HL)		;CHAR COUNT IN B
	INC	B		;ADD 1 IN CASE OF ZERO
CB1:	INC	HL		;PT TO 1ST VALID CHAR
	LD	A,(HL)		;CAPITALIZE COMMAND CHAR
	CALL	UCASE
	LD	(HL),A
	DJNZ	CB1		;CONTINUE TO END OF COMMAND LINE
CB2:	LD	(HL),0		;STORE ENDING <NULL>
	LD	HL,CIBUFF	;SET COMMAND LINE PTR TO 1ST CHAR
	LD	(CIBPTR),HL
	RET

; CHECK FOR ANY CHAR FROM USER CONSOLE;RET W/ZERO SET IF NONE

BREAK:	PUSH	DE		;SAVE DE
	LD	C,11		;CSTS CHECK
	CALL	BDOSB
	CALL	NZ,CONIN		;GET INPUT CHAR
BRKBK:	POP	DE
	RET

; GET THE REQUESTED USER NUMBER FROM THE COMMAND LINE AND VALIDATE IT.

USRNUM:	LD	A,0FFH		;SET HEX CODE TO OFF
	CALL	NUMBER
	CP	MAXUSR+1
	RET	C

; INVALID COMMAND -- PRINT IT

ERROR:	LD	HL,(CIPTR)	;PT TO BEGINNING OF COMMAND LINE
	CALL	PRINTC
	DB	'? ',0
ERR2:	LD	A,(HL)		;GET CHAR
	OR	A		;CLEAR SCREEN?
	JR	Z,ERR1
	PUSH	HL
	CALL	CONOUT		;YES...DO IT...
	POP	HL
	INC	HL		;PT TO NEXT
	JR	ERR2		;CONTINUE
ERR1:	CALL	SUBKIL		;TERMINATE ACTIVE $$$.SUB IF ANY
REST1:	JP	RESTRT		;RESTART CPR

; CHECK TO SEE IF DE PTS TO DELIMITER; IF SO, RET W/ZERO FLAG SET

SDELM:	LD	A,(DE)
	OR	A		;0=DELIMITER
	RET	Z
	CP	' '		;ERROR IF < <SP>
	JR	C,ERROR
	RET	Z		;<SP>=DELIMITER
	CP	5FH		;UNDERSCORE=DELIMITER
	RET	Z
	CP	'.'
	RET	Z
	CP	':'
	RET	Z
	CP	';'
	RET	Z
	CP	'<'
	RET	Z
	CP	'='
	RET	Z
	CP	'>'
	RET

; ADVANCE INPUT PTR TO FIRST NON-BLANK AND FALL THROUGH TO SBLANK

ADVAN:	LD	DE,(CIBPTR)

; SKIP STRING PTED TO BY DE (STRING ENDS IN 0) UNTIL END OF STRING
;   OR NON-BLANK ENCOUNTERED (BEGINNING OF TOKEN)

SBLANK:	LD	A,(DE)
	OR	A
	RET	Z
	CP	' '
	RET	NZ
	INC	DE
	JR	SBLANK

; ADD A TO HL (HL=HL+A)

ADDAH:	ADD	A,L
	LD	L,A
	RET	NC
	INC	H
	RET

;ENTRY FOR CONVERTING DECIMAL AND HEX NUMBERS TO BINARY

NUMBER:	PUSH	AF
	CALL	SCANER		;PARSE COMMAND LINE 
	LD	HL,FCBFN	;POINT TO NUMBER
	LD	DE,0000		;SET UP ACCUMULATING REGISTERS
	LD	C,00		;...DITTO
	POP	AF
	INC	A		;IS HEX CODE SPECIFIED?
	JR	NZ,HEXNUM	;...YES, DO HEX
	LD	BC,0011		;...NOT SURE, BETTER CHECK
	LD	A,'H'		;...THE FIRST 11 CHARS.
	PUSH	HL
	CPIR
	POP	HL
	JR	Z,HEXNUM	;IF 'Z' SET THEN HEX SPECFD.

; PROCESS DECIMAL NUMBER

	LD	BC,0B00H	;'B'=11, 'C'=0

NUM1:	LD	A,(HL)		;GET CHARACTER
	CP	' '		;IS IT THE END?
	JR	Z,NUM2		;...YES, RETURN.
	INC	HL		;PT TO NEXT CHAR
	SUB	'0'		;CONVERT TO BINARY (ASCII 0-9 TO BINARY)
	CP	10		;ERROR IF >= 10
	JR	NC,NUMERR
	LD	D,A		;DIGIT IN D
	XOR	A
	PUSH	BC
	LD	B,10
NUM3:	ADD	A,C		;NEW VALUE = OLD VALUE X 10
	JR	C,NUMER1
	DJNZ	NUM3
	POP	BC
	ADD	A,D		;NEW VALUE = OLD VALUE * 10 + DIGIT
	JR	C,NUMERR		;CHECK FOR RANGE ERROR
 	LD	C,A		;SET NEW VALUE
	DJNZ	NUM1		;COUNT DOWN

NUM2:	LD	A,C		;GET ACCUMULATED VALUE
	RET

NUMER1:POP	BC
NUMERR:	JP	ERROR		;USE ERROR ROUTINE - THIS IS RELATIVE PT

;PROCESS HEX NUMBER

HEXNUM:	LD	A,(HL)
	CP	'H'		;CHECK FOR END
	JR	Z,HNUM4
	CP	' '		;...SAME
	JR	Z,HNUM4
	CP	'0'		;CHECK LOW END
	JR	C,NUMERR
	INC	HL
	CP	'F'+1		;CHECK HIGH END
	JR	NC,NUMERR
	CP	'9'+1		;CHECK FOR DIGIT
	JR	C,HNUM2
	CP	'A'		;CHECK FOR A - F
	JR	C,NUMERR
	ADD	A,9
HNUM2:	RLCA
	RLCA
	RLCA
	RLCA
	LD	B,4
HNUM3:	RLCA
	RL	E
	RL	D
	DJNZ	HNUM3
	JR	HEXNUM
HNUM4:	EX	DE,HL
	LD	A,L		;RETURN WITH NUMBER IN 'HL'
	RET			;AND LOW BYTE IN 'A'

; PT TO DIRECTORY ENTRY IN TBUFF WHOSE OFFSET IS SPECIFIED BY A AND C

DIRPTR:	LD	HL,TBUFF 	;PT TO TEMP BUFFER
	ADD	A,C		;PT TO 1ST BYTE OF DIR ENTRY
	CALL	ADDAH		;PT TO DESIRED BYTE IN DIR ENTRY
	LD	A,(HL)		;GET DESIRED BYTE
	RET

; CHECK FOR SPECIFIED DRIVE AND LOG IT IN IF NOT DEFAULT

SLOGIN:	XOR	A		;SET FCBDN FOR DEFAULT DRIVE
	LD	(FCBDN),A
	CALL	COMLOG		;CHECK DRIVE
	RET	Z
	JR	DLOG5		;DO LOGIN OTHERWISE

; CHECK FOR SPECIFIED DRIVE AND LOG IN DEFAULT DRIVE IF SPECIFIED<>DEFAULT

DLOGIN:	CALL	COMLOG		;CHECK DRIVE
	RET	Z		;ABORT IF SAME
	LD	A,(TDRIVE)		;LOG IN DEFAULT DRIVE
DLOG5:	JP	LOGIN

; ROUTINE COMMON TO BOTH LOGIN ROUTINES; ON EXIT, Z SET MEANS ABORT

TEMPDR	EQU	$+1		;POINTER FOR IN-THE-CODE MODIFICATION
COMLOG:	LD	A,0		;2ND BYTE (IMMEDIATE ARG) IS TEMPDR
	OR	A		;0=NO
	RET	Z
	DEC	A		;COMPARE IT AGAINST DEFAULT
	LD	HL,TDRIVE
	CP	(HL)
	RET			;ABORT IF SAME

.COMMENT \
EXTRACT TOKEN FROM COMMAND LINE AND PLACE IT INTO FCBDN;
FORMAT FCBDN FCB IF TOKEN RESEMBLES FILE NAME AND TYPE (FILENAME.TYP);
ON INPUT, CIBPTR PTS TO CHAR AT WHICH TO START SCAN;
ON OUTPUT, CIBPTR PTS TO CHAR AT WHICH TO CONTINUE AND ZERO FLAG IS RESET
IF '?' IS IN TOKEN

ENTRY POINTS:
SCANER - LOAD TOKEN INTO FIRST FCB
SCANX - LOAD TOKEN INTO FCB PTED TO BY HL
\

SCANER:	LD	HL,FCBDN 	;POINT TO FCBDN
SCANX:	XOR	A		;SET TEMPORARY DRIVE NUMBER TO DEFAULT
	LD	(TEMPDR),A
	CALL	ADVAN		;SKIP TO NON-BLANK OR END OF LINE
	LD	(CIPTR),DE	;SET PTR TO NON-BLANK OR END OF LINE
	LD	A,(DE)		;END OF LINE?
	OR	A		;0=YES
	JR	Z,SCAN2
	SUB	'A'-1		;CONVERT POSSIBLE DRIVE SPEC TO NUMBER
	LD	B,A		;STORE NUMBER (A:=0, B:=1, ETC) IN B
	INC	DE		;PT TO NEXT CHAR
	LD	A,(DE)		;SEE IF IT IS A COLON (:)
	CP	':'
	JR	Z,SCAN3		;YES, WE HAVE A DRIVE SPEC
	DEC	DE		;NO, BACK UP PTR TO FIRST NON-BLANK CHAR
SCAN2:	LD	A,(TDRIVE)	;SET 1ST BYTE OF FCBDN AS DEFAULT DRIVE
	LD	(HL),A
	JR	SCAN4

SCAN3:	LD	A,B		;WE HAVE A DRIVE SPEC
	LD	(TEMPDR),A	;SET TEMPORARY DRIVE
	LD	(HL),B		;SET 1ST BYTE OF FCBDN AS SPECIFIED DRIVE
	INC	DE		;PT TO BYTE AFTER ':'

; EXTRACT FILENAME FROM POSSIBLE FILENAME.TYP

SCAN4:	XOR	A		;A=0
	LD	(QMCNT),A	;INIT COUNT OF NUMBER OF QUESTION MARKS IN FCB
	LD	B,8		;MAX OF 8 CHARS IN FILE NAME
	CALL	SCANF		;FILL FCB FILE NAME

; EXTRACT FILE TYPE FROM POSSIBLE FILENAME.TYP

	LD	B,3		;PREPARE TO EXTRACT TYPE
	CP	'.'		;IF (DE) DELIMITER IS A '.', WE HAVE A TYPE
	JR	NZ,SCAN15		;FILL FILE TYPE BYTES WITH <SP>
	INC	DE		;PT TO CHAR IN COMMAND LINE AFTER '.'
	CALL	SCANF		;FILL FCB FILE TYPE
	JR	SCAN16		;SKIP TO NEXT PROCESSING

SCAN15:	CALL	SCANF4		;SPACE FILL

; FILL IN EX, S1, S2, AND RC WITH ZEROES

SCAN16:	LD	B,4		;4 BYTES
SCAN17:	INC	HL		;PT TO NEXT BYTE IN FCBDN
	LD	(HL),00
	DJNZ	SCAN17

; SCAN COMPLETE -- DE PTS TO DELIMITER BYTE AFTER TOKEN

	LD	(CIBPTR),DE

; SET ZERO FLAG TO INDICATE PRESENCE OF '?' IN FILENAME.TYP

	LD	A,(QMCNT)	;GET NUMBER OF QUESTION MARKS
	OR	A		;SET ZERO FLAG TO INDICATE ANY '?'
	RET

;SCANF -- SCAN TOKEN PTED TO BY DE FOR A MAX OF B BYTES; PLACE IT INTO
;FILE NAME FIELD PTED TO BY HL; EXPAND AND INTERPRET WILD CARDS OF
;'*' AND '?'; ON EXIT, DE PTS TO TERMINATING DELIMITER

SCANF:	CALL	SDELM		;DONE IF DELIMITER ENCOUNTERED - <SP> FILL
	JR	Z,SCANF4
	INC	HL		;PT TO NEXT BYTE IN FCBDN
	CP	'*'		;IS (DE) A WILD CARD?
	JR	NZ,SCANF1		;CONTINUE IF NOT
	LD	(HL),'?'		;PLACE '?' IN FCBDN AND DON'T ADVANCE DE IF SO
	CALL	SCQ		;SCANNER COUNT QUESTION MARKS
	JR	SCANF2

SCANF1:	LD	(HL),A		;STORE FILENAME CHAR IN FCBDN
	INC	DE		;PT TO NEXT CHAR IN COMMAND LINE
	CP	'?'		;CHECK FOR QUESTION MARK (WILD)
	CALL	Z,SCQ		;SCANNER COUNT QUESTION MARKS
SCANF2:	DJNZ	SCANF		;DECREMENT CHAR COUNT UNTIL 8 ELAPSED
SCANF3:	CALL	SDELM		;8 CHARS OR MORE - SKIP UNTIL DELIMITER
	RET	Z		;ZERO FLAG SET IF DELIMITER FOUND
	INC	DE		;PT TO NEXT CHAR IN COMMAND LINE
	JR	SCANF3

;  FILL MEMORY POINTED TO BY HL WITH SPACES FOR B BYTES

SCANF4:	INC	HL		;PT TO NEXT BYTE IN FCBDN
	LD	(HL),' '		;FILL FILENAME PART WITH <SP>
	DJNZ	SCANF4
	RET

;INCREMENT QUESTION MARK COUNT FOR SCANNER
;THIS ROUTINE INCREMENTS THE COUNT OF THE NUMBER OF QUESTION MARKS IN
;THE CURRENT FCB ENTRY

SCQ:	LD	A,(QMCNT)	;GET COUNT
	INC	A		;INCREMENT
	LD	(QMCNT),A	;PUT COUNT
	RET

.COMMENT \
**** Section 5 ****
CPR-Resident Commands


Section 5A
Command: DIR
Function:  To display a directory of the files on disk
and report the space remaining on disk
Forms:
DIR <afn>	Displays the DIR files
DIR <afn> S	Displays the SYS files
DIR <afn> A	Display both DIR and SYS files
DIR <dr>  R	Report remaining disk space only
\

DIR:	CALL	SCANER		;EXTRACT POSSIBLE D:FILENAME.TYP TOKEN
	CALL	SLOGIN		;LOG IN DRIVE IF NECESSARY
	LD	HL,FCBFN 	;MAKE FCB WILD (ALL '?') IF NO FILENAME.TYP
	LD	A,(HL)		;GET FIRST CHAR OF FILENAME.TYP
	CP	' '		;IF <SP>, ALL WILD
	CALL	Z,FILLQ
	CALL	ADVAN		;LOOK AT NEXT INPUT CHAR
	LD	B,0		;SYS TOKEN DEFAULT
	JR	Z,DIR2		;JUMP; THERE ISN'T ONE
	INC	DE		;INCREMENT CIBUFF POINTER
	LD	(CIBPTR),DE	;...AND STORE IT

	CP	REPORT		;REPORT REMAINING SPACE?
	JR	Z,DIR5

	CP	SYSFLG		;LIST ALL FILES?
	JR	Z,GOTSYS	;A=0 B=0

	CP	SOFLG		;LIST SYS FILES ONLY?
	JR	NZ,DIR6		;...NO,
	LD	B,80H		;FLAG SYS FILES ONLY
	JR	DIR2		;A=80H B=80H

GOTSYS:	XOR	A		;SET NO SYSTEM BIT EXAMINATION
	JR	DIR4

DIR6:	DEC	DE		;THERE WERE NO LEGAL DEFAULTS
	LD	(CIBPTR),DE	;...SO DECREMENT CIBUFF POINTER.

DIR2:	LD	A,80H
DIR4:	CALL	DIRPR		;PRINT DIRECTORY FILES
DIR5:	CALL	DIRSPC		;REPORT DISK SPACE.
	RET			;ROUTINE IS FINISHED!!

; DIRECTORY PRINT ROUTINE; ON ENTRY, MSB OF A IS 1 (80H) IF SYSTEM FILES EXCL

DIRPR:	LD	D,A		;STORE SYSTEM FLAG IN D
	LD	E,0		;SET COLUMN COUNTER TO ZERO
	PUSH	DE		;SAVE COLUMN COUNTER (E) AND SYSTEM FLAG (D)
	XOR	A
	LD	(NAMCT),A
	CALL	CRLF
	LD	A,B		;SYS ONLY SPECIFIER
	LD	(SYSTST),A
	CALL	SEARF		;SEARCH FOR SPECIFIED FILE (FIRST OCCURRANCE)
	CALL	Z,PRNNF		;PRINT NO FILE MSG;REG A NOT CHANGED

; ENTRY SELECTION LOOP; ON ENTRY, A=OFFSET FROM SEARF OR SEARN

DIR3:	JR	Z,DIR11		;DONE IF ZERO FLAG SET
	DEC	A		;ADJUST TO RETURNED VALUE
	RRCA			;CONVERT NUMBER TO OFFSET INTO TBUFF
	RRCA
	RRCA
	AND	60H
	LD	C,A		;OFFSET INTO TBUFF IN C (C=OFFSET TO ENTRY)
	LD	A,10		;ADD 10 TO PT TO SYSTEM FILE ATTRIBUTE BIT
	CALL	DIRPTR
	POP	DE		;GET SYSTEM BIT MASK FROM D
	PUSH	DE
	AND	D		;MASK FOR SYSTEM BIT

SYSTST	EQU	$+1		;POINTER TO IN-THE-CODE BUFFER SYSTST
	CP	0
	JR	NZ,DIR10
	LD	A,01
	CALL	DIRPTR
	LD	DE,PRNTNM
	LD	BC,0008
	LDIR
	INC	DE
	LD	C,03
	LDIR

	IF	NOT WIDE
	CALL	PRINT
PRNTNM:	DB '         ','   ','    ', 0
	ENDIF	;NOT WIDE

	IF	WIDE
	CALL	PRINT
PRNTNM:	DB '         ','   ','        ', 0
	ENDIF	;WIDE

	LD	A,(NAMCT)
	INC	A
	LD	(NAMCT),A
	AND	03
	OR	A
	CALL	Z,CRLF

DIR10:	CALL	BREAK		;CHECK FOR ABORT
	JR	NZ,DIR11
	CALL	SEARN		;SEARCH FOR NEXT FILE
	JR	NZ,DIR3		;CONTINUE

DIR11:	POP	DE		;RESTORE STACK
	CALL	CRLF
	RET


;ROUTINE TO CALCULATE REMAINING SPACE ON DISK

DIRSPC:	LD	HL,00		;GET ALLOCATION ADDRESS
	LD	(SVE+1),HL
	LD	C,ALLOC
	CALL	BDOS
	PUSH	HL

;GET Disk Parameter Block (DPB) ADDRESS IN 'HL'

	LD	C,DPB
	CALL	BDOS

;GET PERTINENT INFORMATION LOCATED IN THE DPB

	LD	DE,0002	;OFFSET ADDED TO 'HL'
	ADD	HL,DE	;POINT TO 'BSH'
	LD	A,(HL)	;GET BLOCK ALLOC SIZE SHIFT FACTOR #
	SUB	3	;ELIMINATE SHIFTS FOR 128, 256, 1024
	LD	(SVE2+1),A	;STORE IT FOR 'MVI B' INSTRUCTION	
	INC	DE	;MAKE 'DE' 3
	ADD	HL,DE	;POINT TO & LOAD 'DSM'...
	LD	E,(HL)	;...(THE TOTAL BLOCKS FOR THIS DRIVE)
	INC	HL
	LD	D,(HL)
	INC	DE	;INCREMENT COUNT BY 1 BLOCK
	LD	B,8	;LOAD BIT COUNTER
	POP	HL	;GET BACK ALLOC TABLE ADDRESS

ST1:	LD	A,(HL)	;GET BYTE
ST2:	RLCA		;CARRY SET MEANS BLOCK ALLOCATED.
	PUSH	AF
	JR	C,ST3	;BLOCK RESERVED...GET NEXT BIT

	PUSH	HL
	LD	HL,(SVE+1)	;FREE BLOCK...ADD 1 TO COUNT
	INC	HL
	LD	(SVE+1),HL
	POP	HL

ST3:	DEC	DE	;DECREMENT THE BLOCK COUNTER
	LD	A,D
	OR	E	;IS IT THE LAST BLOCK?...
	JR	Z,ST5	;...YES, END PROGRAMME.

	POP	AF	;...NO
	DJNZ	ST2	;HAVE WE FINISHED WITH THIS BYTE?...
	LD	B,8	;...YES, REPLENISH BIT COUNTER.
	INC	HL	;POINT TO NEXT BYTE...
	JR	ST1	;...AND START AGAIN.

ST5:	POP	AF	;EQUALIZE STACK
SVE:	LD	HL,0000	;TOTAL UNALLOCATED BLOCKS WERE PUT HERE
SVE2:	LD	B,0	;BLOCK SIZE-SHIFT FACTOR WAS PUT HERE
	INC	B	;TEST FOR ZERO SHIFT...=1024 SIZE
	DEC	B
	JR	Z,ST7
ST6:	ADD	HL,HL	;DOUBLE THE CALCULATED DISK SPACE
	DJNZ	ST6	;SHOULD WE DOUBLE IT AGAIN?...
ST7:	CALL	CRLF
	CALL	DECOUT	;...NO, PRINT THE NUMBER.

	CALL	PRINT
	DB '(K) left on disk',CR,LF,0
	RET

;DECIMAL OUTPUT ROUTINE
;CONVERTS BINARY DECIMAL NUMBER IN 'HL' TO ASCII.
;AND OUTPUTS NUMBER TO CONSOL

DECOUT:	PUSH	HL
	PUSH	DE
	LD	BC,-10
	LD	DE,-1
DECOT2:	ADD	HL,BC
	INC	DE
	JR	C,DECOT2
	LD	BC,10
	ADD	HL,BC
	EX	DE,HL
	LD	A,H
	OR	L
	CALL	NZ,DECOUT
	LD	A,E
	ADD	A,'0'
	CALL	CONOUT
	POP	DE
	POP	HL
	RET

; FILL FCB @HL WITH '?'

FILLQ:	LD	B,11		;NUMBER OF CHARS IN FN & FT
FQLP:	LD	(HL),'?'		;STORE '?'
	INC	HL
	DJNZ	FQLP
	RET

NAMCT:	DB	0

.COMMENT \
Section 5B
Command: ERA
Function:  Erase files
Forms:
ERA <afn>	Erase Specified files and print their names
\
	IF	NOT RAS		;NOT FOR REMOTE-ACCESS SYSTEM
ERA:	CALL	SCANER		;PARSE FILE SPECIFICATION
	CP	11		;ALL WILD (ALL FILES = 11 '?')?
	JR	NZ,ERA1		;IF NOT, THEN DO ERASES
	CALL	PRINTC
	DB	'All','?',0
	CALL	CONIN		;GET REPLY
	CP	'Y'		;YES?
	JP	NZ,RESTRT		;RESTART CPR IF NOT
	CALL	CRLF		;NEW LINE
ERA1:	CALL	SLOGIN		;LOG IN SELECTED DISK IF ANY
	XOR	A		;PRINT ALL FILES (EXAMINE SYSTEM BIT)
	LD	B,A		;NO SYS-ONLY OPT TO DIRPR
	CALL	DIRPR		;PRINT DIRECTORY OF ERASED FILES
	LD	DE,FCBDN 	;DELETE FILE SPECIFIED
	CALL	DELETE
	CALL	DIRSPC		;REPORT DISK SPACE
	RET			;REENTER CPR
	ENDIF			;RAS

.COMMENT \
Section 5C
Command: LIST
Function:  Print out specified file on the LST: Device
Forms:
LIST <ufn>	Print file (NO Paging)
\

;LIST:	LD	A,0FFH		;TURN ON PRINTER FLAG
;	JR	TYPE

.COMMENT \
Section 5D
Command: TYPE
Function:  Print out specified file on the CON: Device
Forms:
TYPE <ufn>	Print file
TYPE <ufn> P	Print file with paging flag	
\

;TYPE:	XOR	A		;TURN OFF PRINTER FLAG

; ENTRY POINT FOR CPR LIST FUNCTION (LIST)

;TYPE0:	LD	(PRFLG),A	;SET FLAG

TYPE:	CALL	SCANER		;EXTRACT FILENAME.TYP TOKEN
	JP	NZ,ERROR	;ERROR IF ANY QUESTION MARKS
	CALL	SLOGIN		;LOG IN SELECTED DISK IF ANY
	CALL	OPENF		;OPEN SELECTED FILE
	JP	Z,ERRLOG		;ABORT IF ERROR
	CALL	CRLF		;NEW LINE

	IF	NOT LBUFF
TYPEE:	LD	C,SECOUN	;USER SPECIFIED BUFFER SIZE

	ELSE

TYPEE:	LD	HL,0002		;HIGH BYTE OF BIOS START
	LD	C,(HL)		;USE IT AS A BUFFER COUNTER
	ENDIF

	LD	DE,128		;...AND SIZE OF EACH SECTOR
	LD	HL,TPA-128	;POINT TO START OF DMA/BUFFER-128
TYPE1:	PUSH	BC
	PUSH	DE		;SAVE #128
	ADD	HL,DE		;INCREMENT DMA/BUFFER BY 128
	PUSH	HL		;...AND SAVE IT.
	EX	DE,HL		;PUT IT IN 'DE'
	CALL	DMASET		;...AND SET THE DMA TO IT.
	CALL	READF		;READ IN ONE SECTOR
	POP	HL		;GET BACK DMA/BUFFER POINTER
	POP	DE		;...AND # 128
	POP	BC
	JR	NZ,TYP		;JUMP IF END OF FILE
	DEC	C		;IS THE DMA/BUFFER FULL?
	JR	NZ,TYPE1	;...NO, CONTINUE.
				;...YES, FALL THROUGH AND PRINT IT.

TYP:	ADD	HL,DE		;POINT TO END OF FILLED BUFFER
	DEC	HL		;POINT TO LAST CHARACTER
	LD	A,(HL)		;GET IT
	PUSH	AF		;...AND SAVE IT
	LD	(HL),0		;PUT A ZERO IN IT'S PLACE
	LD	HL,TPA		;POINT TO START OF 4K BUFFER

PRIN2:	LD	A,(HL)		;GET A CHARACTER
	OR	A		;END OF BUFFER?
	JR	NZ,PRIN4	;...NO, PRINT CHARACTER
	POP	AF		;...YES, PRINT LAST CHARC
	CALL	CONOUT		;...AND REFILL THE BUFFER.
	JR	TYPEE

PRIN4:	CP	1AH		;END OF FILE?
	JR	Z,TYP1		;...YES, QUIT.
	CALL	CONOUT		;...NO, PRINT THE CHARACTER.
	INC	HL		;INCREMENT TO NEXT CHARACTER
	PUSH	HL		;SAVE ADDRESS
	CALL	BREAK		;DOES USER WANT TO ABORT?
	POP	HL
	JR	Z,PRIN2		;...NO, CONTINUE PRINTING.
				;...YES, USER WANTS OUT IF 'NZ'
TYP1:	POP	AF		;RESTORE THE STACK
	CALL	DEFDMA		;RESET THE DMA
	RET

;SAVE FILE ROUTINES

	IF	NOT RAS		;NOT FOR REMOTE-ACCESS SYSTEM
SAVE:	LD	A,0FFH		;SET HEX CODE, OFF
	CALL	NUMBER		;EXTRACT NUMBER FROM COMMAND LINE
	LD	L,A		;HL=PAGE COUNT
	LD	H,0
	PUSH	HL		;SAVE PAGE COUNT
	CALL	EXTEST		;TEST FOR EXISTENCE OF FILE AND ABORT IF SO
	LD	C,16H		;BDOS MAKE FILE
	CALL	GRBDOS
	POP	HL		;GET PAGE COUNT
	JR	Z,SAVE3		;ERROR?
	XOR	A		;SET RECORD COUNT FIELD OF NEW FILE'S FCB
	LD	(FCBCR),A
	CALL	ADVAN		;LOOK FOR 'S' FOR SECTOR OPTION
	INC	DE		;PT TO AFTER 'S' TOKEN
	CP	SECTFLG
	JR	Z,SAVE0
	DEC	DE		;NO 'S' TOKEN, SO BACK UP
	ADD	HL,HL		;DOUBLE IT FOR HL=SECTOR (128 BYTES) COUNT

SAVE0:	LD	(CIBPTR),DE	;SET PTR TO BAD TOKEN OR AFTER GOOD TOKEN
	LD	DE,TPA		;PT TO START OF SAVE AREA (TPA)
SAVE1:	LD	A,H		;DONE WITH SAVE?
	OR	L		;HL=0 IF SO
	JR	Z,SAVE2
	DEC	HL		;COUNT DOWN ON SECTORS
	PUSH	HL		;SAVE PTR TO BLOCK TO SAVE
	LD	HL,128		;128 BYTES PER SECTOR
	ADD	HL,DE		;PT TO NEXT SECTOR
	PUSH	HL		;SAVE ON STACK
	CALL	DMASET		;SET DMA ADDRESS FOR WRITE (ADDRESS IN DE)
	LD	DE,FCBDN 	;WRITE SECTOR
	LD	C,15H		;BDOS WRITE SECTOR
	CALL	BDOSB		;SAVE BC
	POP	DE		;GET PTR TO NEXT SECTOR IN DE
	POP	HL		;GET SECTOR COUNT
	JR	NZ,SAVE3		;WRITE ERROR?
	JR	SAVE1		;CONTINUE
SAVE2:	LD	DE,FCBDN 	;CLOSE SAVED FILE
	CALL	CLOSE
	INC	A		;ERROR?
	JR	NZ,SAVE4
SAVE3:	CALL	PRNLE		;PRINT 'NO SPACE' ERROR
SAVE4:	CALL	DEFDMA		;SET DMA TO 0080
	RET			;RESTART CPR

;Test File in FCB for existence, ask user to delete if so, and abort if he
;choses not to

EXTEST:	CALL	SCANER		;EXTRACT FILE NAME
	JP	NZ,ERROR	;'?' IS NOT PERMITTED
	CALL	SLOGIN		;LOG IN SELECTED DISK
	CALL	SEARF		;LOOK FOR SPECIFIED FILE
	LD	DE,FCBDN	;PT TO FILE FCB
	RET	Z		;OK IF NOT FOUND
	PUSH	DE		;SAVE PTR TO FCB
	CALL	PRINTC
	DB	'Delete File ?',0
	CALL	CONIN		;GET RESPONSE
	POP	DE		;GET PTR TO FCB
	CP	'Y'		;KEY ON YES
	JP	NZ,RSTCPR	;RESTART IF NO
	PUSH	DE		;SAVE PTR TO FCB
	CALL	DELETE		;DELETE FILE
	POP	DE		;GET PTR TO FCB
	RET
	ENDIF			;RAS

.COMMENT \
Section 5F
Command: REN
Function:  To change the name of an existing file
Forms:
REN <New ufn>=<Old ufn>	Perform function
\

	IF	NOT RAS		;NOT FOR REMOTE-ACCESS SYSTEM
REN:	CALL	EXTEST		;TEST FOR FILE EXISTENCE AND RETURN
				; IF FILE DOESN'T EXIST; ABORT IF IT DOES
	LD	A,(TEMPDR)	;SAVE CURRENT DEFAULT DISK
	PUSH	AF		;SAVE ON STACK
REN0:	LD	HL,FCBDN 	;SAVE NEW FILE NAME
	LD	DE,FCBDM
	LD	BC,16		;16 BYTES
	LDIR
	CALL	ADVAN		;ADVANCE CIBPTR
	CP	'='		;'=' OK
	JR	NZ,REN4
REN1:	EX	DE,HL		;PT TO CHAR AFTER '=' IN HL
	INC	HL
	LD	(CIBPTR),HL	;SAVE PTR TO OLD FILE NAME
	CALL	SCANER		;EXTRACT FILENAME.TYP TOKEN
	JR	NZ,REN4		;ERROR IF ANY '?'
	POP	AF		;GET OLD DEFAULT DRIVE
	LD	B,A		;SAVE IT
	LD	HL,TEMPDR	;COMPARE IT AGAINST CURRENT DEFAULT DRIVE
	LD	A,(HL)		;MATCH?
	OR	A
	JR	Z,REN2
	CP	B		;CHECK FOR DRIVE ERROR
	LD	(HL),B
	JR	NZ,REN4
REN2:	LD	(HL),B
	XOR	A
	LD	(FCBDN),A	;SET DEFAULT DRIVE
	LD	DE,FCBDN 	;RENAME FILE
	LD	C,17H		;BDOS RENAME FCT
	CALL	GRBDOS
	RET	NZ
REN3:	CALL	PRNNF		;PRINT NO FILE MSG
REN4:	JP	ERRLOG
	ENDIF			;RAS

.COMMENT \
Section 5G
Command: USER
Function:  Change current USER number
Forms:
USER <unum>	Select specified user number;<unum> is in DEC
\

USER:	CALL	USRNUM		;EXTRACT USER NUMBER FROM COMMAND LINE
	LD	E,A		;PLACE USER NUMBER IN E
	CALL	SETUSR		;SET SPECIFIED USER
RSTJMP:	JP	RCPRNL		;RESTART CPR

.COMMENT \
Section 5H
Command: DFU
Function:  Set the Default User Number for the command/file scanner
(MEMLOAD)
Forms:
DFU <unum>	Select Default User Number;<unum> is in DEC
\

DFU:	CALL	USRNUM		;GET USER NUMBER
	LD	(DFUSR),A	;PUT IT AWAY
	JR	RSTJMP		;RESTART CPR (NO DEFAULT LOGIN)

.COMMENT \
Section 5I
Command: JUMP
Function:  To Call the program (subroutine) at the specified address
without loading from disk
Forms:
JUMP <adr>		Call at <adr>;<adr> is in HEX
\

	IF	NOT RAS		;NOT FOR REMOTE-ACCESS SYSTEM
JUMP:	XOR	A		;SET HEX CODE IN 'A',A=0
	CALL	NUMBER		;GET LOAD ADDRESS IN HL
	JR	CALLPROG	;PERFORM CALL
	ENDIF			;RAS

.COMMENT \
Section 5J
Command: GO
Function:  To Call the program in the TPA without loading
loading from disk. Same as JUMP 100H, but much
more convenient, especially when used with
parameters for programs like STAT. Also can be
allowed on remote-access systems with no problems.

Form:
GO <parameters like for COMMAND>
\

	IF	NOT RAS		;ONLY IF RAS
GO:	LD	HL,TPA		;Always to TPA
	JR	CALLPROG	;Perform call
	ENDIF			;END OF GO FOR RAS

.COMMENT \
Section 5K
Command: COM file processing
Function:  To load the specified COM file from disk and execute it
Forms:
<command>
\

COM:	LD	A,(FCBFN)	;ANY COMMAND?
	CP	' '		;' ' MEANS COMMAND WAS 'D:' TO SWITCH
	JR	NZ,COM1		;NOT <SP>, SO MUST BE TRANSIENT OR ERROR
	LD	A,(TEMPDR)	;LOOK FOR DRIVE SPEC
	OR	A		;IF ZERO, JUST BLANK
	JP	Z,RCPRNL
	DEC	A		;ADJUST FOR LOG IN
	LD	(TDRIVE),A	;SET DEFAULT DRIVE
	CALL	SETU0D		;SET DRIVE WITH USER 0
	CALL	LOGIN		;LOG IN DRIVE
	JP	RCPRNL		;RESTART CPR
COM1:	LD	A,(FCBFT)	;FILE TYPE MUST BE BLANK
	CP	' '
	JP	NZ,ERROR
	LD	HL,COMMSG	;PLACE DEFAULT FILE TYPE (COM) INTO FCB
	LD	DE,FCBFT	;COPY INTO FILE TYPE
	LD	BC,3		;3 BYTES
	LDIR
	LD	HL,TPA		;SET EXECUTION/LOAD ADDRESS
	PUSH	HL		;SAVE FOR EXECUTION
	CALL	MEMLOAD		;LOAD MEMORY WITH FILE SPECIFIED IN CMD LINE
	POP	HL		;GET EXECUTION ADDRESS
	RET	NZ		;RETURN (ABORT) IF LOAD ERROR

;CALLPROG IS THE ENTRY POINT FOR THE EXECUTION OF THE LOADED
;PROGRAM;ON ENTRY TO THIS ROUTINE, HL MUST CONTAIN THE EXECUTION
;ADDRESS OF THE PROGRAM (SUBROUTINE) TO EXECUTE

CALLPROG:
	LD	(EXECADR),HL	;PERFORM IN-LINE CODE MODIFICATION
	CALL	DLOGIN		;LOG IN DEFAULT DRIVE
	CALL	SCANER		;SEARCH COMMAND LINE FOR NEXT TOKEN
	LD	HL,TEMPDR	;SAVE PTR TO DRIVE SPEC
	PUSH	HL
	LD	A,(HL)		;SET DRIVE SPEC
	LD	(FCBDN),A
	LD	HL,FCBDN+10H	;PT TO 2ND FILE NAME
	CALL	SCANX		;SCAN FOR IT AND LOAD IT INTO FCBDN+16
	POP	HL		;SET UP DRIVE SPECS
	LD	A,(HL)
	LD	(FCBDM),A
	XOR	A
	LD	(FCBCR),A
	LD	DE,TFCB		;COPY TO DEFAULT FCB
	LD	HL,FCBDN 	;FROM FCBDN
	LD	BC,33		;SET UP DEFAULT FCB
	LDIR
	LD	HL,CIBUFF
COM4:	LD	A,(HL)		;SKIP TO END OF 2ND FILE NAME
	OR	A		;END OF LINE?
	JR	Z,COM5
	CP	' '		;END OF TOKEN?
	JR	Z,COM5
	INC	HL
	JR	COM4

; LOAD COMMAND LINE INTO TBUFF

COM5:	LD	B,0		;SET CHAR COUNT
	LD	DE,TBUFF+1	;PT TO CHAR POS
COM6:	LD	A,(HL)		;COPY COMMAND LINE TO TBUFF
	LD	(DE),A
	OR	A		;DONE IF ZERO
	JR	Z,COM7
	INC	B		;INCR CHAR COUNT
	INC	HL		;PT TO NEXT
	INC	DE
	JR	COM6

; RUN LOADED TRANSIENT PROGRAM

COM7:	LD	A,B		;SAVE CHAR COUNT
	LD	(TBUFF),A
	CALL	CRLF		;NEW LINE
	CALL	DEFDMA		;SET DMA TO 0080
	CALL	SETUD		;SET USER/DISK

; EXECUTION (CALL) OF PROGRAM (SUBROUTINE) OCCURS HERE

EXECADR	EQU	$+1		;CHANGE ADDRESS FOR IN-LINE CODE MODIFICATION
	CALL	TPA		;CALL TRANSIENT
	CALL	DEFDMA		;SET DMA TO 0080, IN CASE
				;PROG CHANGED IT ON US
	CALL	SETU0D		;SET USER 0/DISK
	CALL	LOGIN		;LOGIN DISK
	JP	RESTRT		;RESTART CPR

; TRANSIENT LOAD ERROR

COM8:	POP	HL		;CLEAR RETURN ADDRESS
	CALL	RESETUSR	;RESET CURRENT USER NUMBER
				;  RESET MUST BE DONE BEFORE LOGIN
ERRLOG:	CALL	DLOGIN		;LOG IN DEFAULT DISK
ERRJMP:	JP	ERROR

.COMMENT \
Section 5L
Command: GET
Function:  To load the specified file from disk to the specified address
Forms:
GET <adr> <ufn>	Load the specified file at the specified page;
<adr> is in HEX
\

	IF	NOT RAS		;NOT FOR REMOTE-ACCESS SYSTEM
GET:	XOR	A		;SET HEX CODE IN 'A', A=0
	CALL	NUMBER		;GET LOAD ADDRESS IN HL
	PUSH	HL		;SAVE ADDRESS
	CALL	SCANER		;GET FILE NAME
	POP	HL		;RESTORE ADDRESS
	JR	NZ,ERRJMP	;MUST BE UNAMBIGUOUS
	ENDIF
;FALL THRU TO MEMLOAD

;LOAD MEMORY WITH THE FILE WHOSE NAME IS SPECIFIED IN THE COMMAND LINE
;ON INPUT, HL CONTAINS STARTING ADDRESS TO LOAD

MEMLOAD:CALL	MLOAD		;USER MEMORY LOAD SUBROUTINE
	PUSH	AF		;SAVE RETURN STATUS
	CALL	RESETUSR	;RESET USER NUMBER
	POP	AF		;GET RETURN STATUS
	RET

.COMMENT \
MEMORY LOAD SUBROUTINE
EXIT POINTS ARE A SIMPLE RETURN WITH THE ZERO FLAG SET IF NO ERROR,
A SIMPLE RETURN WITH THE ZERO FLAG RESET (NZ) IF MEMORY FULL, OR A JMP TO
COM8 IF COM FILE NOT FOUND
\

MLOAD:	LD	(LOADADR),HL	;SET LOAD ADDRESS
	CALL	GETUSR		;GET CURRENT USER NUMBER
	LD	(TMPUSR),A	;SAVE IT FOR LATER
	LD	(TSELUSR),A 	;TEMP USER TO SELECT

.COMMENT \
MLA is a reentry point for a non-standard CP/M Modification
This is the return point for when the .COM (or GET) file is not found the
first time, Drive A: is selected for a second attempt
\

MLA:	CALL	SLOGIN		;LOG IN SPECIFIED DRIVE IF ANY
	CALL	OPENF		;OPEN COMMAND.COM FILE
	JR	NZ,MLA1		;FILE FOUND - LOAD IT

; ERROR ROUTINE TO SELECT USER 0 IF ALL ELSE FAILS

DFUSR	EQU	$+1		;MARK IN-THE-CODE VARIABLE
	LD	A,DEFUSR	;GET DEFAULT USER
TSELUSR	EQU	$+1		;MARK IN-THE-CODE VARIABLE
	CP	DEFUSR		;SAME?
	JR	Z,MLA0		;JUMP IF
	LD	(TSELUSR),A	;ELSE PUT DOWN NEW ONE
	LD	E,A
	CALL	SETUSR		;GO SET NEW USER NUMBER
	JR	MLA		;AND TRY AGAIN

; ERROR ROUTINE TO SELECT DRIVE A: IF DEFAULT WAS ORIGINALLY SELECTED

MLA0:	LD	HL,TEMPDR	;GET DRIVE FROM CURRENT COMMAND
	XOR	A		;A=0
	OR	(HL)
	JP	NZ,COM8		;ERROR IF ALREADY DISK A:
	LD	(HL),1		;SELECT DRIVE A:
	JR	MLA

; FILE FOUND -- PROCEED WITH LOAD

LOADADR	EQU	$+1		;MEMORY LOAD ADDRESS (IN-LINE CODE MOD)
MLA1:	LD	HL,TPA		;SET START ADDRESS OF MEMORY LOAD
ML2:	LD	A,ENTRY/256-1 	;GET HIGH-ORDER ADR OF JUST BELOW CPR
	CP	H		;ARE WE GOING TO OVERWRITE THE CPR?
	JR	C,PRNLE		;ERROR IF SO
	PUSH	HL		;SAVE ADDRESS OF NEXT SECTOR
	EX	DE,HL		;... IN DE
	CALL	DMASET		;SET DMA ADDRESS FOR LOAD
	LD	DE,FCBDN 	;READ NEXT SECTOR
	CALL	READ
	POP	HL		;GET ADDRESS OF NEXT SECTOR
	JR	NZ,ML3		;READ ERROR OR EOF?
	LD	DE,128		;MOVE 128 BYTES PER SECTOR
	ADD	HL,DE		;PT TO NEXT SECTOR IN HL
	JR	ML2

ML3:	DEC	A		;LOAD COMPLETE
	RET	Z		;OK IF ZERO, ELSE FALL THRU TO PRNLE

; LOAD ERROR

PRNLE:	CALL	PRINTC
	DB	'Full',0
	LD	A,1		;SET NON-ZERO TO INDICATE ERROR
	OR	A		;SET FLAG
	RET

	END
